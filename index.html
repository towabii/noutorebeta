<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音響信号変換アプリ v6</title>
    <script src="https://cdn.jsdelivr.net/npm/kuromoji@0.1.2/build/kuromoji.js"></script>
    <style>
        :root {
            --bg-color: #f0f2f5; --fg-color: #ffffff; --text-color: #1c1c1e;
            --primary-color: #007aff; --primary-hover: #0056b3; --border-color: #e0e0e0;
            --shadow-color: rgba(0, 0, 0, 0.1); --success-color: #34c759; --error-color: #ff3b30;
        }
        html.dark-mode {
            --bg-color: #1c1c1e; --fg-color: #2c2c2e; --text-color: #f2f2f7;
            --primary-color: #0a84ff; --primary-hover: #0060df; --border-color: #444446;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color); color: var(--text-color);
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; margin: 0; padding: 1rem; box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s;
        }
        .container {
            background-color: var(--fg-color); padding: 2.5rem; border-radius: 1.5rem;
            box-shadow: 0 8px 32px var(--shadow-color); width: 100%; max-width: 700px;
            text-align: center; transition: background-color 0.3s;
        }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; }
        h1 { color: var(--primary-color); margin: 0; font-size: 2rem; }
        .theme-switch { display: flex; align-items: center; cursor: pointer; }
        .theme-switch input { display: none; }
        .slider { width: 40px; height: 20px; background: #ccc; border-radius: 20px; position: relative; transition: background 0.3s; }
        .slider:before { content: ''; position: absolute; width: 16px; height: 16px; background: white; border-radius: 50%; top: 2px; left: 2px; transition: transform 0.3s; }
        .theme-switch input:checked + .slider { background-color: var(--primary-color); }
        .theme-switch input:checked + .slider:before { transform: translateX(20px); }
        .section { margin-bottom: 2rem; }
        textarea {
            width: 100%; height: 120px; padding: 1rem; border: 1px solid var(--border-color);
            border-radius: 0.75rem; font-size: 1rem; resize: vertical; box-sizing: border-box;
            background-color: var(--bg-color); color: var(--text-color);
        }
        button {
            background-color: var(--primary-color); color: #fff; border: none; padding: 1rem 2rem;
            border-radius: 0.75rem; cursor: pointer; font-size: 1rem; font-weight: 600;
            transition: background-color 0.3s, transform 0.1s; margin-top: 1rem;
        }
        button:hover:not(:disabled) { background-color: var(--primary-hover); }
        button:active:not(:disabled) { transform: scale(0.98); }
        button:disabled { background-color: #8e8e93; cursor: not-allowed; }
        #result-display {
            margin-top: 1rem; padding: 1rem; border: 2px dashed var(--border-color);
            border-radius: 0.75rem; min-height: 50px; background-color: var(--bg-color);
            font-size: 1.2rem; font-weight: bold; color: var(--error-color); text-align: left;
        }
        .status { margin-top: 1rem; color: #8e8e93; font-style: italic; }
        .loader { display: none; }
        .loader.active { display: block; margin-top: 1rem; }
        .progress-bar { width: 100%; background-color: var(--border-color); border-radius: 5px; overflow: hidden; height: 10px; }
        .progress-bar-inner { width: 0%; height: 100%; background-color: var(--primary-color); transition: width 0.2s; }
        
        @media (max-width: 600px) {
            body { padding: 0.5rem; }
            .container { padding: 1.5rem; }
            h1 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>音響信号 v6</h1>
        <label class="theme-switch">
            <input type="checkbox" id="theme-toggle">
            <span class="slider"></span>
        </label>
    </div>

    <div class="loader active" id="loader">
        <p id="loading-status">辞書の準備をしています...</p>
        <div class="progress-bar">
            <div class="progress-bar-inner" id="progress-bar-inner"></div>
        </div>
    </div>

    <div class="section">
        <textarea id="text-input" placeholder="ここにメッセージを入力" disabled></textarea>
        <button id="play-button" disabled>音に変換して再生</button>
    </div>
    <div class="section">
        <button id="listen-button" disabled>マイクで読み取り開始</button>
        <div id="result-display"></div>
        <p class="status" id="status-text">待機中</p>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', async () => {
    // --- グローバル変数 ---
    let audioContext, audioStream, analyser, animationFrameId, tokenizer;
    let isListening = false, listeningState = 'IDLE', lastDetectionTime = 0;

    // --- DOM要素 ---
    const textInput = document.getElementById('text-input'), playButton = document.getElementById('play-button');
    const listenButton = document.getElementById('listen-button'), resultDisplay = document.getElementById('result-display');
    const statusText = document.getElementById('status-text'), loader = document.getElementById('loader');
    const loadingStatus = document.getElementById('loading-status'), progressBar = document.getElementById('progress-bar-inner');
    const themeToggle = document.getElementById('theme-toggle');

    // --- 信号定義 & マッピング ---
    const NOTE_DURATION = 0.1, PAUSE_DURATION = 0.05;
    const START_SIGNAL_FREQ = 300, END_SIGNAL_FREQ = 4000;
    const charToFreqPair = {};

    function assignFrequencies() {
        const lowGroup = [697, 770, 852, 941], highGroup = Array.from({length: 15}, (_, i) => 1209 + i * 150);
        const chars = [...new Set([...`あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをんがぎぐげござじずぜぞだぢづでどばびぶべぼぱぴぷぺぽぁぃぅぇぉゃゅょっー、。？！`].sort())];
        chars.forEach((char, i) => {
            const lowIndex = Math.floor(i / highGroup.length) % lowGroup.length;
            const highIndex = i % highGroup.length;
            charToFreqPair[char] = { f1: lowGroup[lowIndex], f2: highGroup[highIndex] };
        });
    }
    assignFrequencies();

    // --- IndexedDB & 辞書キャッシュ管理 ---
    const DB_NAME = 'KuromojiDB', STORE_NAME = 'DictionaryStore', DB_VERSION = 1;
    const DIC_FILES = ['base.dat.gz', 'check.dat.gz', 'conn.dat.gz', 'unk.dat.gz', 'char.def.gz', 'unk.def.gz', 'tid.dat.gz', 'tid_pos.dat.gz', 'tid_map.dat.gz'];

    function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onupgradeneeded = e => e.target.result.createObjectStore(STORE_NAME);
            request.onsuccess = e => resolve(e.target.result);
            request.onerror = e => reject(e.target.error);
        });
    }

    async function getCachedDictionary() {
        const db = await openDB();
        return new Promise(resolve => {
            const transaction = db.transaction(STORE_NAME, 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const files = {}; let count = 0;
            DIC_FILES.forEach(name => {
                store.get(name).onsuccess = e => {
                    if (e.target.result) files[name] = e.target.result;
                    if (++count === DIC_FILES.length) resolve(Object.keys(files).length === DIC_FILES.length ? files : null);
                };
            });
        });
    }

    async function cacheDictionary() {
        const db = await openDB();
        const transaction = db.transaction(STORE_NAME, 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const dicPath = "https://cdn.jsdelivr.net/npm/kuromoji@0.1.2/dict/";
        let loaded = 0;
        for (const name of DIC_FILES) {
            const response = await fetch(dicPath + name);
            const data = await response.arrayBuffer();
            store.put(data, name);
            loaded++;
            progressBar.style.width = `${(loaded / DIC_FILES.length) * 100}%`;
        }
        return getCachedDictionary();
    }

    // --- 初期化処理 ---
    (async function initialize() {
        loadingStatus.textContent = 'キャッシュを確認中...';
        let dicFiles = await getCachedDictionary();
        if (!dicFiles) {
            loadingStatus.textContent = '辞書をダウンロード中... (初回のみ)';
            dicFiles = await cacheDictionary();
        }
        loadingStatus.textContent = '辞書を構築中...';
        const dicPath = Object.fromEntries(Object.entries(dicFiles).map(([name, data]) => [name, URL.createObjectURL(new Blob([data]))]));
        
        kuromoji.builder({ dicPath: null, dicFiles }).build((err, _tokenizer) => {
            if (err) { loadingStatus.textContent = "辞書の構築に失敗しました。"; return; }
            tokenizer = _tokenizer;
            loader.style.display = 'none';
            textInput.disabled = false; playButton.disabled = false; listenButton.disabled = false;
        });
    })();
    
    // --- テーマ管理 ---
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
        document.documentElement.classList.add('dark-mode');
        themeToggle.checked = true;
    }
    themeToggle.addEventListener('change', () => {
        document.documentElement.classList.toggle('dark-mode');
        localStorage.setItem('theme', themeToggle.checked ? 'dark' : 'light');
    });

    // --- AudioContext & HELPERS ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    function initializeAudioContext() { if (!audioContext) audioContext = new AudioContext(); }
    function katakanaToHiragana(src) { return src.replace(/[\u30a1-\u30f6]/g, m => String.fromCharCode(m.charCodeAt(0) - 0x60)); }

    // --- 音声再生 & 解析ロジック (v5ベース) ---
    playButton.addEventListener('click', async () => { /* ... (ロジックはv5から変更なし) ... */
        initializeAudioContext();
        const text = textInput.value;
        if (!text || !tokenizer) return;
        playButton.disabled = true;
        const tokens = tokenizer.tokenize(text);
        const hiraganaText = tokens.map(t => t.reading ? katakanaToHiragana(t.reading) : t.surface_form).join('');
        const sequence = [{f1: START_SIGNAL_FREQ}];
        for (const char of hiraganaText) {
            if (charToFreqPair[char]) sequence.push(charToFreqPair[char]);
        }
        sequence.push({f1: END_SIGNAL_FREQ});
        await playSequence(sequence);
        playButton.disabled = false;
    });

    function playSequence(sequence) { /* ... (ロジックはv5から変更なし) ... */
        return new Promise(resolve => {
            let currentTime = audioContext.currentTime;
            for (const {f1, f2} of sequence) {
                [f1, f2].forEach(freq => {
                    if (!freq) return;
                    const osc = audioContext.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(freq, currentTime);
                    const gain = audioContext.createGain();
                    gain.gain.setValueAtTime(0, currentTime);
                    gain.gain.linearRampToValueAtTime(0.3, currentTime + 0.01);
                    gain.gain.linearRampToValueAtTime(0, currentTime + NOTE_DURATION);
                    osc.connect(gain).connect(audioContext.destination);
                    osc.start(currentTime);
                    osc.stop(currentTime + NOTE_DURATION);
                });
                currentTime += NOTE_DURATION + PAUSE_DURATION;
            }
            setTimeout(resolve, (currentTime - audioContext.currentTime) * 1000);
        });
    }

    listenButton.addEventListener('click', () => { /* ... (ロジックはv5から変更なし) ... */
        initializeAudioContext();
        !isListening ? startListening() : stopListening();
    });

    async function startListening() { /* ... (ロジックはv5から変更なし) ... */
        try {
            audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const source = audioContext.createMediaStreamSource(audioStream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 8192;
            source.connect(analyser);
            isListening = true; listeningState = 'IDLE';
            listenButton.textContent = '読み取り停止'; statusText.textContent = '「開始信号」を待機中...';
            resultDisplay.textContent = '';
            analyzeSound();
        } catch (err) { statusText.textContent = 'マイクの起動に失敗。設定を確認してください。'; }
    }
    
    function stopListening() { /* ... (ロジックはv5から変更なし) ... */
        if(audioStream) audioStream.getTracks().forEach(t => t.stop());
        cancelAnimationFrame(animationFrameId);
        isListening = false; listenButton.textContent = 'マイクで読み取り開始'; statusText.textContent = '待機中';
    }

    function analyzeSound() { /* ... (ロジックはv5から変更なし) ... */
        if (!isListening) return;
        const dataArray = new Float32Array(analyser.frequencyBinCount);
        analyser.getFloatFrequencyData(dataArray);
        const peaks = getPeaks(dataArray, -60);
        if (peaks.length > 0) {
            const signal = findClosestSignal(peaks);
            const now = Date.now();
            if (signal && now - lastDetectionTime > (NOTE_DURATION + PAUSE_DURATION) * 800) {
                 if (listeningState === 'IDLE' && signal.type === 'START') {
                    listeningState = 'RECEIVING'; statusText.textContent = '信号受信中...';
                } else if (listeningState === 'RECEIVING') {
                    if (signal.type === 'END') {
                        listeningState = 'IDLE'; statusText.textContent = '受信完了。「開始信号」を待機中...';
                    } else if (signal.type === 'CHAR') {
                        resultDisplay.textContent += signal.char;
                    }
                }
                lastDetectionTime = now;
            }
        }
        animationFrameId = requestAnimationFrame(analyzeSound);
    }
    
    function getPeaks(data, threshold) { /* ... (ロジックはv5から変更なし) ... */
        const peaks = [];
        for (let i = 1; i < data.length - 1; i++) {
            if (data[i] > threshold && data[i] > data[i - 1] && data[i] > data[i + 1]) {
                peaks.push(i * audioContext.sampleRate / analyser.fftSize);
            }
        }
        return peaks;
    }

    function findClosestSignal(peaks) { /* ... (ロジックはv5から変更なし) ... */
        const tolerance = 25;
        for (const p of peaks) {
            if (Math.abs(p - START_SIGNAL_FREQ) < tolerance) return { type: 'START' };
            if (Math.abs(p - END_SIGNAL_FREQ) < tolerance) return { type: 'END' };
        }
        for (const char in charToFreqPair) {
            const {f1, f2} = charToFreqPair[char];
            let foundF1 = false, foundF2 = false;
            for (const p of peaks) {
                if (Math.abs(p - f1) < tolerance) foundF1 = true;
                if (Math.abs(p - f2) < tolerance) foundF2 = true;
            }
            if (foundF1 && foundF2) return { type: 'CHAR', char: char };
        }
        return null;
    }
});
</script>

</body>
</html>
