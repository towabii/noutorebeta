<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音響信号変換アプリ v2</title>
    <style>
        /* CSSスタイル（変更なし） */
        body {
            font-family: 'Helvetica Neue', Arial, 'Hiragin o Kaku Gothic ProN', 'Hiragino Sans', Meiryo, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1em 0;
        }
        .container {
            background-color: #fff;
            padding: 2em;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 600px;
            text-align: center;
        }
        h1 {
            color: #1a73e8;
            margin-bottom: 1em;
        }
        .section {
            margin-bottom: 2em;
        }
        h2 {
            border-bottom: 2px solid #1a73e8;
            padding-bottom: 0.5em;
            margin-bottom: 1em;
            font-size: 1.2em;
        }
        textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1em;
            resize: vertical;
            box-sizing: border-box;
        }
        button {
            background-color: #1a73e8;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s;
            margin-top: 10px;
        }
        button:hover {
            background-color: #155ab6;
        }
        button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }
        #result-display {
            margin-top: 1em;
            padding: 1em;
            border: 1px dashed #ccc;
            border-radius: 5px;
            min-height: 50px;
            background-color: #f9f9f9;
            font-size: 1.2em;
            font-weight: bold;
            color: #e84118;
            word-wrap: break-word;
            text-align: left;
        }
        .status {
            margin-top: 1em;
            color: #888;
            font-style: italic;
        }
        .info {
            font-size: 0.8em;
            color: #555;
            text-align: left;
            margin-top: 1em;
            border-left: 3px solid #1a73e8;
            padding-left: 1em;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>独自音響信号 会話アプリ v2</h1>

    <div class="section">
        <h2>1. 日本語テキストを音に変換</h2>
        <textarea id="text-input" placeholder="ここにひらがなやカタカナを入力 (例: アプリカイハツ)"></textarea>
        <button id="play-button">音に変換して再生</button>
    </div>

    <div class="section">
        <h2>2. 音を日本語テキストに変換</h2>
        <button id="listen-button">マイクで読み取り開始</button>
        <div id="result-display"></div>
        <p class="status" id="status-text">待機中</p>
        <div class="info">
            <strong>ヒント:</strong>
            <p>・「読み取り開始」を押すと、まず「開始の音」を待ち受けます。</p>
            <p>・マイクの許可ポップアップが表示されない場合、ブラウザの設定でマイクがブロックされていないか確認してください。この機能はHTTPS接続されたページでのみ動作します。</p>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- グローバル変数と定数 ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioContext;
    let audioStream;
    let analyser;
    let animationFrameId;
    let isListening = false;
    let listeningState = 'IDLE'; // 'IDLE', 'RECEIVING'
    let lastDetectedChar = null;
    let lastDetectionTime = 0;

    // --- DOM要素 ---
    const textInput = document.getElementById('text-input');
    const playButton = document.getElementById('play-button');
    const listenButton = document.getElementById('listen-button');
    const resultDisplay = document.getElementById('result-display');
    const statusText = document.getElementById('status-text');

    // --- 信号定義 ---
    const START_SIGNAL_FREQ = 300; // 開始信号の周波数
    const END_SIGNAL_FREQ = 350;   // 終了信号の周波数
    const NOTE_DURATION = 0.15;    // 1文字あたりの音の長さ
    const PAUSE_DURATION = 0.08;   // 文字間の無音時間

    // --- 文字と周波数のマッピング ---
    const charToFreq = {};
    const freqToChar = {};
    
    // 周波数を体系的に生成
    function assignFrequencies() {
        let baseFreq = 440; // A4 (ラ)
        const chars = [
            // ひらがな
            'あいうえお', 'かきくけこ', 'さしすせそ', 'たちつてと', 'なにぬねの',
            'はひふへほ', 'まみむめも', 'やゆよ', 'らりるれろ', 'わをん',
            'がぎぐげご', 'ざじずぜぞ', 'だぢづでど', 'ばびぶべぼ', 'ぱぴぷぺぽ',
            // カタカナ
            'アイウエオ', 'カキクケコ', 'サシスセソ', 'タチツテト', 'ナニヌネノ',
            'ハヒフヘホ', 'マミムメモ', 'ヤユヨ', 'ラリルレロ', 'ワヲン',
            'ガギグゲゴ', 'ザジズゼゾ', 'ダヂヅデド', 'バビブベボ', 'パピプペポ',
        ].join('');

        for (const char of chars) {
            charToFreq[char] = baseFreq;
            baseFreq *= Math.pow(2, 1 / 12); // 半音ずつ上げる
        }
        // 逆引きマップも作成
        for (const [char, freq] of Object.entries(charToFreq)) {
            freqToChar[freq.toFixed(2)] = char;
        }
    }
    assignFrequencies();


    // --- AudioContextの初期化 ---
    // ユーザーの操作があるまで初期化を遅延させる
    function initializeAudioContext() {
        if (!audioContext) {
            try {
                audioContext = new AudioContext();
            } catch (e) {
                alert('Web Audio APIはこのブラウザではサポートされていません。');
            }
        }
    }

    // --- 機能1: テキストを音に変換 ---
    playButton.addEventListener('click', () => {
        initializeAudioContext();
        const text = textInput.value;
        if (!text || !audioContext) return;

        const sequence = [START_SIGNAL_FREQ];
        for (const char of text) {
            if (charToFreq[char]) {
                sequence.push(charToFreq[char]);
            }
        }
        sequence.push(END_SIGNAL_FREQ);
        
        playFrequencySequence(sequence);
    });

    async function playFrequencySequence(sequence) {
        playButton.disabled = true;
        let currentTime = audioContext.currentTime;

        for (const freq of sequence) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(freq, currentTime);
            
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0, currentTime);
            gainNode.gain.linearRampToValueAtTime(0.5, currentTime + 0.01);
            gainNode.gain.linearRampToValueAtTime(0, currentTime + NOTE_DURATION);

            oscillator.connect(gainNode);
            oscillator.start(currentTime);
            oscillator.stop(currentTime + NOTE_DURATION);

            currentTime += NOTE_DURATION + PAUSE_DURATION;
        }
        setTimeout(() => { playButton.disabled = false; }, (currentTime - audioContext.currentTime) * 1000);
    }

    // --- 機能2: 音をテキストに変換 ---
    listenButton.addEventListener('click', () => {
        initializeAudioContext();
        if (!audioContext) return;

        if (!isListening) {
            startListening();
        } else {
            stopListening();
        }
    });

    async function startListening() {
        try {
            audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const source = audioContext.createMediaStreamSource(audioStream);
            
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 16384; // 周波数解像度を上げる
            analyser.minDecibels = -90;
            analyser.maxDecibels = -10;
            analyser.smoothingTimeConstant = 0.8;

            source.connect(analyser);

            isListening = true;
            listeningState = 'IDLE';
            listenButton.textContent = '読み取り停止';
            statusText.textContent = '「開始信号」を待機中...';
            resultDisplay.textContent = '';
            
            analyzeSound();

        } catch (err) {
            if (err.name === 'NotAllowedError') {
                statusText.textContent = 'マイクの使用が許可されませんでした。ブラウザの設定を確認してください。';
            } else {
                statusText.textContent = 'マイクの起動に失敗しました。';
            }
            console.error('マイクへのアクセスエラー:', err);
        }
    }

    function stopListening() {
        if (audioStream) {
            audioStream.getTracks().forEach(track => track.stop());
        }
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        isListening = false;
        listeningState = 'IDLE';
        listenButton.textContent = 'マイクで読み取り開始';
        statusText.textContent = '待機中';
    }
    
    function analyzeSound() {
        if (!isListening) return;

        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Float32Array(bufferLength);
        analyser.getFloatFrequencyData(dataArray);

        let maxVal = -Infinity;
        let maxIndex = -1;

        for (let i = 0; i < bufferLength; i++) {
            if (dataArray[i] > maxVal) {
                maxVal = dataArray[i];
                maxIndex = i;
            }
        }

        if (maxVal > -60) { // ノイズフィルタの閾値を少し調整
            const detectedFreq = maxIndex * audioContext.sampleRate / analyser.fftSize;
            const signal = findClosestSignal(detectedFreq);

            const now = Date.now();
            if (signal && (signal.char !== lastDetectedChar || now - lastDetectionTime > 300)) {
                
                if (listeningState === 'IDLE' && signal.type === 'START') {
                    listeningState = 'RECEIVING';
                    statusText.textContent = '信号受信中...（「終了信号」で完了）';
                    resultDisplay.textContent = '';
                } else if (listeningState === 'RECEIVING') {
                    if (signal.type === 'END') {
                        listeningState = 'IDLE';
                        statusText.textContent = '受信完了。「開始信号」を待機中...';
                    } else if (signal.type === 'CHAR') {
                        resultDisplay.textContent += signal.char;
                    }
                }
                lastDetectedChar = signal.char;
                lastDetectionTime = now;
            }
        } else {
            lastDetectedChar = null;
        }

        animationFrameId = requestAnimationFrame(analyzeSound);
    }
    
    function findClosestSignal(freq) {
        const tolerance = 15; // 許容する周波数の誤差 (Hz)

        // 識別コードのチェック
        if (Math.abs(freq - START_SIGNAL_FREQ) < tolerance) return { type: 'START', char: 'START' };
        if (Math.abs(freq - END_SIGNAL_FREQ) < tolerance) return { type: 'END', char: 'END' };

        // 文字のチェック
        let closestChar = null;
        let minDiff = Infinity;
        for (const char in charToFreq) {
            const targetFreq = charToFreq[char];
            const diff = Math.abs(freq - targetFreq);
            if (diff < minDiff && diff < tolerance) {
                minDiff = diff;
                closestChar = char;
            }
        }
        
        if(closestChar) {
            return { type: 'CHAR', char: closestChar };
        }
        return null;
    }
});
</script>

</body>
</html>
