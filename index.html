<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音響信号変換アプリ v13 (Final Polished Build / 修正版)</title>
    <style>
        /* =================================
           CSSスタイル (一切省略なし)
           ================================= */
        :root {
            --bg-color: #f0f2f5; --fg-color: #ffffff; --text-color: #1c1c1e;
            --primary-color: #007aff; --primary-hover: #0056b3; --border-color: #e0e0e0;
            --shadow-color: rgba(0, 0, 0, 0.1); --success-color: #34c759; --error-color: #ff3b30;
        }
        html.dark-mode {
            --bg-color: #1c1c1e; --fg-color: #2c2c2e; --text-color: #f2f2f7;
            --primary-color: #0a84ff; --primary-hover: #0060df; --border-color: #444446;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }
        @keyframes pulse-border {
            0% { border-color: var(--primary-color); }
            50% { border-color: var(--success-color); }
            100% { border-color: var(--primary-color); }
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color); color: var(--text-color);
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; margin: 0; padding: 1rem; box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s;
        }
        .container {
            background-color: var(--fg-color); padding: 2.5rem; border-radius: 1.5rem;
            box-shadow: 0 8px 32px var(--shadow-color); width: 100%; max-width: 700px;
            text-align: center; transition: background-color 0.3s;
        }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; }
        h1 { color: var(--primary-color); margin: 0; font-size: 2rem; }
        .theme-switch { display: flex; align-items: center; cursor: pointer; }
        .theme-switch input { display: none; }
        .slider { width: 40px; height: 20px; background: #ccc; border-radius: 20px; position: relative; transition: background 0.3s; }
        .slider:before { content: ''; position: absolute; width: 16px; height: 16px; background: white; border-radius: 50%; top: 2px; left: 2px; transition: transform 0.3s; }
        .theme-switch input:checked + .slider { background-color: var(--primary-color); }
        .theme-switch input:checked + .slider:before { transform: translateX(20px); }
        .section { margin-bottom: 2rem; }
        #playback-display {
            font-size: 1.2rem; margin-bottom: 0.5rem; color: var(--text-color); min-height: 1.5em;
            letter-spacing: 2px;
        }
        #playback-display .highlight {
            background-color: var(--primary-color); color: white; border-radius: 3px;
        }
        textarea { width: 100%; height: 120px; padding: 1rem; border: 1px solid var(--border-color); border-radius: 0.75rem; font-size: 1rem; resize: vertical; box-sizing: border-box; background-color: var(--bg-color); color: var(--text-color); }
        button { background-color: var(--primary-color); color: #fff; border: none; padding: 1rem 2rem; border-radius: 0.75rem; cursor: pointer; font-size: 1rem; font-weight: 600; transition: background-color 0.3s, transform 0.1s; margin-top: 1rem; }
        button:hover:not(:disabled) { background-color: var(--primary-hover); }
        button:active:not(:disabled) { transform: scale(0.98); }
        button:disabled { background-color: #8e8e93; opacity: 0.7; cursor: not-allowed; }
        .receiver-area { position: relative; }
        #kanji-convert-button { position: absolute; bottom: 5px; right: 5px; padding: 0.3rem 0.8rem; font-size: 0.8rem; margin-top: 0; background-color: var(--success-color); display: none; }
        #result-display { margin-top: 1rem; padding: 1rem; border: 2px dashed var(--border-color); border-radius: 0.75rem; min-height: 50px; background-color: var(--bg-color); font-size: 1.2rem; font-weight: bold; color: var(--error-color); text-align: left; word-wrap: break-word; }
        #result-display.receiving { animation: pulse-border 1.5s infinite; }
        .status { margin-top: 1rem; color: #8e8e93; font-style: italic; min-height: 1.2em; }
        @media (max-width: 600px) { body { padding: 0.5rem; } .container { padding: 1.5rem; } h1 { font-size: 1.5rem; } }
    </style>
</head>
<body>
<div class="container">
    <div class="header"><h1>音響信号 v13</h1> <label class="theme-switch"><input type="checkbox" id="theme-toggle"><span class="slider"></span></label></div>
    <div class="section">
        <div id="playback-display"></div>
        <textarea id="text-input" placeholder="ひらがな・カタカナでメッセージを入力"></textarea>
        <button id="play-button">音に変換して再生</button>
    </div>
    <div class="section"><button id="listen-button">マイクで読み取り開始</button><div class="receiver-area"><div id="result-display"></div><button id="kanji-convert-button">漢字に変換</button></div><p class="status" id="status-text">待機中</p></div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
    // =================================
    // グローバル変数 & DOM要素
    // =================================
    let audioContext; let audioStream; let analyser; let animationFrameId;
    let isListening = false; let isTransmitting = false;
    let listeningState = 'IDLE'; let lastDetectionTime = 0;

    const textInput = document.getElementById('text-input'), playButton = document.getElementById('play-button');
    const listenButton = document.getElementById('listen-button'), resultDisplay = document.getElementById('result-display');
    const statusText = document.getElementById('status-text'), themeToggle = document.getElementById('theme-toggle');
    const kanjiConvertButton = document.getElementById('kanji-convert-button'), playbackDisplay = document.getElementById('playback-display');

    // =================================
    // 信号定義と周波数マッピング
    // =================================
    const NOTE_DURATION = 0.13, PAUSE_DURATION = 0.09;
    const START_SIGNAL_FREQ = 300, END_SIGNAL_FREQ = 4000;
    const charToFreqPair = {};

    function assignFrequencies() {
        const LOW_FREQUENCIES = [697, 770, 852, 941, 1046, 1150];
        const HIGH_FREQUENCIES = [1336, 1477, 1633, 1800, 1980, 2150, 2350, 2550, 2780, 3000, 3250, 3500, 3750];
        const allChars = `あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをんがぎぐげござじずぜぞだぢづでどばびぶべぼぱぴぷぺぽぁぃぅぇぉゃゅょっアイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲンガギグゲゴザジズゼゾダヂヅデドバビブベボパピプペポァィゥェォャュョッー、。？！「」`;
        const chars = [...new Set(allChars.split(''))].sort();
        if (chars.length > LOW_FREQUENCIES.length * HIGH_FREQUENCIES.length) { console.error("エラー: 対応文字数が周波数の組み合わせ上限を超えています。"); return; }
        chars.forEach((char, i) => { const lowIndex = Math.floor(i / HIGH_FREQUENCIES.length) % LOW_FREQUENCIES.length; const highIndex = i % HIGH_FREQUENCIES.length; charToFreqPair[char] = { f1: LOW_FREQUENCIES[lowIndex], f2: HIGH_FREQUENCIES[highIndex] }; });
    }

    // =================================
    // 初期化処理
    // =================================
    assignFrequencies();
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches, savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark' || (!savedTheme && prefersDark)) { document.documentElement.classList.add('dark-mode'); themeToggle.checked = true; }
    
    // =================================
    // AudioContext管理 (最重要修正箇所)
    // =================================
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    async function initializeAudioContext() {
        if (!audioContext) {
            try { audioContext = new AudioContext(); } catch (e) { statusText.textContent = "このブラウザはWeb Audio APIをサポートしていません。"; return false; }
        }
        if (audioContext.state === 'suspended') { try { await audioContext.resume(); } catch (e) { statusText.textContent = "音声の再生を開始できませんでした。"; return false; } }
        return true;
    }

    // =================================
    // 機能1: テキストを音に変換 (+視覚フィードバック)
    // =================================
    async function playSequence(sequence, textSpans) {
        let cumulativeTime = 0;
        const baseTime = audioContext.currentTime;

        for (let i = 0; i < sequence.length; i++) {
            const {f1, f2} = sequence[i];
            const isCharSignal = i > 0 && i < sequence.length - 1;
            const playTime = baseTime + cumulativeTime;
            
            // 視覚フィードバックのタイミングを調整
            if (isCharSignal && textSpans[i-1]) {
                setTimeout(() => textSpans[i-1].classList.add('highlight'), cumulativeTime * 1000);
                setTimeout(() => textSpans[i-1].classList.remove('highlight'), (cumulativeTime + NOTE_DURATION) * 1000);
            }

            // 音声のスケジューリング
            [f1, f2].forEach(freq => {
                if (!freq) return;
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(freq, playTime);
                gainNode.gain.setValueAtTime(0, playTime);
                gainNode.gain.linearRampToValueAtTime(0.5, playTime + 0.01);
                gainNode.gain.linearRampToValueAtTime(0, playTime + NOTE_DURATION);
                oscillator.connect(gainNode).connect(audioContext.destination);
                oscillator.start(playTime);
                oscillator.stop(playTime + NOTE_DURATION);
            });
            cumulativeTime += NOTE_DURATION + PAUSE_DURATION;
        }
        return new Promise(resolve => setTimeout(resolve, cumulativeTime * 1000));
    }
    
    // =================================
    // 機能2: 音をテキストに変換 (高信頼性受信)
    // =================================
    function analyzeSound() {
        if (!isListening) return;
        const dataArray = new Float32Array(analyser.frequencyBinCount);
        analyser.getFloatFrequencyData(dataArray);
        const signal = findClosestSignalFromData(dataArray);
        const now = Date.now();
        if (signal && now - lastDetectionTime > (NOTE_DURATION + PAUSE_DURATION) * 1000 * 0.9) {
            if (listeningState === 'IDLE' && signal.type === 'START') {
                listeningState = 'RECEIVING'; statusText.textContent = '信号受信中...'; resultDisplay.classList.add('receiving');
            } else if (listeningState === 'RECEIVING') {
                if (signal.type === 'END') {
                    listeningState = 'IDLE'; statusText.textContent = '受信完了。「開始信号」待機中...';
                    if (resultDisplay.textContent) kanjiConvertButton.style.display = 'inline-block';
                    resultDisplay.classList.remove('receiving');
                } else if (signal.type === 'CHAR') { resultDisplay.textContent += signal.char; }
            }
            lastDetectionTime = now;
        }
        animationFrameId = requestAnimationFrame(analyzeSound);
    }
    
    function findClosestSignalFromData(data) {
        const threshold = -55; 
        const freqToIndex = freq => Math.round(freq * analyser.fftSize / audioContext.sampleRate);
        
        // 開始/終了信号を優先的にチェック
        if (data[freqToIndex(START_SIGNAL_FREQ)] > threshold) return { type: 'START' };
        if (data[freqToIndex(END_SIGNAL_FREQ)] > threshold) return { type: 'END' };
        
        // 文字信号をチェック
        for (const char in charToFreqPair) { 
            const {f1, f2} = charToFreqPair[char]; 
            if (data[freqToIndex(f1)] > threshold && data[freqToIndex(f2)] > threshold) {
                return { type: 'CHAR', char: char }; 
            }
        }
        return null;
    }

    async function startListening() {
        if (!(await initializeAudioContext())) return;
        try {
            audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const source = audioContext.createMediaStreamSource(audioStream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 8192; 
            analyser.smoothingTimeConstant = 0.5;
            source.connect(analyser);
            isListening = true; 
            listeningState = 'IDLE';
            listenButton.textContent = '停止'; 
            playButton.disabled = true;
            statusText.textContent = '「開始信号」待機中...'; 
            resultDisplay.textContent = '';
            kanjiConvertButton.style.display = 'none';
            analyzeSound();
        } catch (err) { 
            statusText.textContent = 'マイクの起動に失敗。アクセスを許可してください。'; 
            console.error("マイク起動エラー:", err); 
            isListening = false; 
        }
    }

    function stopListening() {
        if (audioStream) audioStream.getTracks().forEach(track => track.stop());
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        isListening = false;
        listenButton.textContent = 'マイクで読み取り開始'; 
        playButton.disabled = false;
        statusText.textContent = '待機中';
        resultDisplay.classList.remove('receiving');
    }

    // =================================
    // 機能3: かな漢字変換 (★修正箇所)
    // =================================
    async function convertToKanji() {
        const text = resultDisplay.textContent;
        if (!text) return;
        
        kanjiConvertButton.textContent = '変換中...';
        kanjiConvertButton.disabled = true;
        
        try {
            // 注意: このGoogle Transliterate APIは非公式であり、現在ではCORSポリシーなどにより動作しない可能性が非常に高いです。
            const url = `https://www.google.com/transliterate?langpair=ja-Hira|ja&text=${encodeURIComponent(text)}`;
            const res = await fetch(url);
            
            if (!res.ok) {
                throw new Error(`API Error: ${res.statusText}`);
            }
            
            const data = await res.json();
            
            if (data && data.length > 0 && data[0].length > 1 && data[0][1].length > 0) {
                resultDisplay.textContent = data.map(segment => segment[1][0]).join('');
            } else {
                throw new Error('変換データが空、または予期しない形式です。');
            }
        } catch (e) {
            statusText.textContent = '漢字変換に失敗しました。現在この機能は利用できない可能性があります。';
            console.error("漢字変換エラー:", e);
        } finally {
            kanjiConvertButton.textContent = '漢字に変換';
            kanjiConvertButton.disabled = false;
            kanjiConvertButton.style.display = 'none'; // 変換後はボタンを非表示
        }
    }

    // =================================
    // イベントリスナー
    // =================================
    themeToggle.addEventListener('change', () => { 
        document.documentElement.classList.toggle('dark-mode'); 
        localStorage.setItem('theme', themeToggle.checked ? 'dark' : 'light'); 
    });
    
    playButton.addEventListener('click', async () => {
        if (isTransmitting || isListening) return;
        if (!(await initializeAudioContext())) return;
        
        const text = textInput.value;
        if (!text) return;
        
        isTransmitting = true; 
        playButton.disabled = true; 
        listenButton.disabled = true;
        statusText.textContent = "信号を送信中...";
        playbackDisplay.innerHTML = [...text].map(c => `<span>${c}</span>`).join('');
        const textSpans = playbackDisplay.querySelectorAll('span');

        const sequence = [{f1: START_SIGNAL_FREQ}];
        for (const char of text) { 
            if (charToFreqPair[char]) {
                sequence.push(charToFreqPair[char]);
            }
        }
        sequence.push({f1: END_SIGNAL_FREQ});
        
        await playSequence(sequence, textSpans);
        
        isTransmitting = false; 
        playButton.disabled = false; 
        listenButton.disabled = false;
        statusText.textContent = "送信完了";
    });
    
    listenButton.addEventListener('click', () => { 
        if (isTransmitting) return; 
        isListening ? stopListening() : startListening(); 
    });
    
    // ★修正箇所: イベントリスナーから関数を呼び出すように変更
    kanjiConvertButton.addEventListener('click', convertToKanji);
});
</script>
</body>
</html>
