<!doctype html>
<html lang="ja">
    <head>
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width,initial-scale=1"/>
        <title>翻訳</title>
        <link id="favicon" rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🧱</text></svg>">
        <script src="https://cdn.jsdelivr.net/npm/qrcode@1/build/qrcode.min.js"></script>
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700;900&family=Noto+Sans+JP:wght@400;500;700&display=swap'); :root {
                --bg-start: #0a0a2a;
                --bg-end: #020024;
                --panel-bg: rgba(18, 18, 58, 0.7);
                --panel-border: rgba(138, 43, 226, 0.3);
                --accent-color: #944dff;
                --text-primary: #e0e7ff;
                --text-secondary: #a7b3d9;
                --cell-bg: rgba(0, 0, 0, 0.25);
                --board-border: #8a2be2;
                --tile-size: clamp(24px, 4vh, 48px);
                --preview-tile-size: clamp(16px, 2.5vh, 22px);
            }

            html,body {
                height: 100%;
                margin: 0;
                font-family: 'Roboto', 'Noto Sans JP', "Hiragino Kaku Gothic ProN", sans-serif;
                background: radial-gradient(circle, var(--bg-start) 0%, var(--bg-end) 100%);
                color: var(--text-primary);
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                user-select: none;
                overflow: hidden;
            }

            .container {
                display: flex;
                align-items: center;
                justify-content: center;
                min-height: 100vh;
                width: 100%;
                padding: 16px;
                box-sizing: border-box;
            }

            .app {
                width: 100%;
                max-width: 1800px;
                display: grid;
                gap: clamp(12px, 2vw, 24px);
                align-items: start;
                justify-content: center;
                position: relative;
                transition: grid-template-columns 0.4s ease;
            }

            .app.single-player-mode {
                grid-template-columns: clamp(180px, 15vw, 240px) min-content clamp(180px, 15vw, 240px);
            }

            .app.single-player-mode .side-panel.left { order: 1; }
            .app.single-player-mode .game-container { order: 2; }
            .app.single-player-mode .side-panel.right { order: 3; }

            .app.vs-cpu-mode {
                grid-template-columns: clamp(180px, 15vw, 240px) min-content auto min-content clamp(180px, 15vw, 240px);
                max-width: 2400px;
            }

            .app.vs-cpu-mode .side-panel.left { order: 1; }
            .app.vs-cpu-mode .game-container { order: 2; }
            .app.vs-cpu-mode #cpu-container { order: 3; }
            .app.vs-cpu-mode .side-panel.right { order: 4; }

            .app.game-inactive-blur::before {
                content: '';
                position: absolute;
                inset: 0;
                background: rgba(10, 10, 42, 0.2);
                backdrop-filter: blur(4px);
                z-index: 29;
            }

            .side-panel {
                display: flex;
                flex-direction: column;
                gap: 16px;
            }

            .panel-card {
                background: var(--panel-bg);
                border: 1px solid var(--panel-border);
                border-radius: 12px;
                padding: 16px;
                backdrop-filter: blur(10px);
                box-shadow: 0 0 15px rgba(138, 43, 226, 0.15);
            }

            .panel-card h3 {
                margin: 0 0 12px 0;
                font-size: 16px;
                font-weight: 700;
                color: var(--accent-color);
                text-align: center;
                letter-spacing: 1px;
                text-transform: uppercase;
            }

            .game-container {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 16px;
                transition: transform 0.1s ease-out;
            }

            .game-header {
                width: 100%;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .title {
                font-size: clamp(20px, 2.5vw, 28px);
                font-weight: 900;
                color: #fff;
                letter-spacing: 2px;
                text-transform: uppercase;
                text-shadow: 0 0 8px var(--accent-color);
            }

            .meta-box {
                background: var(--panel-bg);
                border: 1px solid var(--panel-border);
                padding: 8px 16px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 700;
                box-shadow: 0 0 10px rgba(138, 43, 226, 0.15);
            }

            .board-wrap {
                position: relative;
            }

            .board {
                width: calc(var(--tile-size) * 10);
                height: calc(var(--tile-size) * 20);
                background: rgba(0,0,0,0.3);
                border-radius: 10px;
                border: 3px solid var(--board-border);
                padding: 6px;
                box-sizing: border-box;
                display: grid;
                grid-template-columns: repeat(10, 1fr);
                grid-template-rows: repeat(20, 1fr);
                gap: 1px;
                position: relative;
                box-shadow: 0 0 20px var(--board-border), inset 0 0 10px rgba(138, 43, 226, 0.3);
                transition: box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out;
            }

            #game-overlay {
                position: absolute;
                inset: 6px;
                background: rgba(2, 0, 36, 0.85);
                border-radius: 10px;
                z-index: 30;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                text-align: center;
                color: #fff;
                padding: 40px;
                box-sizing: border-box;
            }

            .overlay-content { width: 100%; }

            .overlay-content h2 {
                font-size: 48px;
                font-weight: 900;
                letter-spacing: 0.1em;
                text-shadow: 0 0 15px #fff, 0 0 25px var(--accent-color);
                margin: 0;
                white-space: nowrap;
                animation: gameover-text-zoom 0.5s cubic-bezier(0.25, 1, 0.5, 1) forwards;
                transform: scale(0.5);
                opacity: 0;
            }
            @keyframes gameover-text-zoom { to { transform: scale(1); opacity: 1; } }

            .overlay-content p { font-size: 20px; margin-top: 8px; margin-bottom: 24px; }
            #start-screen .overlay-footer, #animation-mode-screen .overlay-footer { flex-direction: column; }
            .overlay-footer {
                width: 100%;
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 12px;
                margin-top: auto;
            }

            #start-screen .overlay-footer .btn, #animation-mode-screen .overlay-footer .btn {
                width: 90%;
                max-width: 280px;
            }

            .cpu-select-container {
                position: relative;
                width: 90%;
                max-width: 280px;
            }

            .cpu-level-dropdown {
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease-in-out;
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                background: rgba(0,0,0,0.2);
                padding: 0 10px;
                border-radius: 8px;
            }

            .cpu-level-dropdown.open { max-height: 200px; padding: 10px; }
            .cpu-level-dropdown .btn { flex: 1 1 50px; min-width: 50px; font-size: 12px; padding: 8px; }

            #countdown {
                font-size: 120px;
                font-weight: 900;
                color: #fff;
                text-shadow: 0 0 20px var(--accent-color), 0 0 40px var(--accent-color);
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 31;
            }

            .cell { background: var(--cell-bg); position: relative; transition: background-color 0.2s ease; }
            .cell.dead { background-color: #334155; }

            .tile {
                width: 100%;
                height: 100%;
                border-radius: 3px;
                position: absolute;
                top: 0;
                left: 0;
                background-color: currentColor;
                box-shadow: inset 0 0 5px rgba(255,255,255,0.4), 0 0 10px currentColor;
            }
            .tile.garbage { background-color: #64748b; box-shadow: inset 0 0 4px rgba(0,0,0,0.5); }
            .ghost-tile {
                width: 100%;
                height: 100%;
                border-radius: 3px;
                background-color: rgba(255, 255, 255, 0.2);
                position: absolute;
                top: 0;
                left: 0;
                border: 1px dashed rgba(255,255,255,0.5);
                box-sizing: border-box;
            }

            .preview-box { width: 100%; height: calc(var(--preview-tile-size) * 6); display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.2); border-radius: 8px; }
            .piece-grid { display: grid; grid-template-columns: repeat(4, var(--preview-tile-size)); grid-template-rows: repeat(4, var(--preview-tile-size)); }
            .mini-cell { width: var(--preview-tile-size); height: var(--preview-tile-size); position: relative; }
            .mini-cell .tile { box-shadow: inset 0 0 3px rgba(255,255,255,0.4), 0 0 5px currentColor; }
            .score-grid { display: flex; flex-direction: column; gap: 8px; }
            .scorebox { display: flex; justify-content: space-between; font-size: 14px; color: var(--text-secondary); }
            .scorebox span:last-child { font-weight: 700; color: var(--text-primary); min-width: 60px; text-align: right; display: inline-block; }
            .controls-panel { display: flex; flex-direction: column; gap: 10px; margin-top: 16px; }

            .btn { padding: 10px 12px; border-radius: 8px; background: linear-gradient(145deg, #4f23a6, #3b1a7d); color: var(--text-primary); border: 1px solid var(--panel-border); cursor: pointer; font-weight: 700; text-transform: uppercase; transition: all 0.2s ease; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
            .btn:hover { background: linear-gradient(145deg, #6a34d9, #4f23a6); box-shadow: 0 0 15px var(--accent-color); }
            .btn.ghost { background: transparent; border-style: dashed; }
            .note { font-size: 12px; color: var(--text-secondary); line-height: 1.6; }
            @keyframes line-clear-animation { 0% { transform: scale(1.1); opacity: 1; background: #fff; box-shadow: 0 0 25px #fff; } 50% { opacity: 0.8; } 100% { transform: scale(0); opacity: 0; background: var(--accent-color); } }
            .line-clearing .tile:not(.garbage) { background: #fff !important; animation: line-clear-animation 0.4s ease-out forwards; }
            .board.line-clearing-effect { border-color: #fff; box-shadow: 0 0 40px #fff, 0 0 70px var(--accent-color), inset 0 0 20px rgba(255, 255, 255, 0.5); }
            @keyframes piece-lock-animation { 0% { transform: translateY(-5%); background: rgba(255, 255, 255, 0.6); opacity: 1; } 50% { transform: translateY(0) scale(1.05, 0.95); background: rgba(255, 255, 255, 0.2); } 100% { transform: translateY(0) scale(1, 1); background: transparent; opacity: 1; } }
            .lock-flash-effect { position: absolute; inset: 0; border-radius: 3px; animation: piece-lock-animation 0.2s ease-out; pointer-events: none; }
            .particle { position: absolute; width: 8px; height: 8px; background: #fff; border-radius: 50%; pointer-events: none; z-index: 50; box-shadow: 0 0 10px #fff; animation: particle-anim 0.6s ease-out forwards; }
            @keyframes particle-anim { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(var(--x), var(--y)) scale(0); opacity: 0; } }
            .hidden { display: none !important; }

            /* New Animations */
            @keyframes shake-hard-drop { 0%, 100% { transform: translateX(0); } 20%, 60% { transform: translateX(-2px); } 40%, 80% { transform: translateX(2px); } }
            .shake-hard-drop { animation: shake-hard-drop 0.15s linear; }
            .board.combo-1 { box-shadow: 0 0 25px #ffab00, inset 0 0 10px #ffab0080; }
            .board.combo-2 { box-shadow: 0 0 30px #ff6d00, inset 0 0 12px #ff6d0080; }
            .board.combo-3 { box-shadow: 0 0 35px #dd2c00, inset 0 0 15px #dd2c0080; }
            .board.combo-4 { box-shadow: 0 0 40px #aa00ff, inset 0 0 20px #aa00ff80; }

            /* Loader and initial screens... */
            #loader { position: fixed; inset: 0; background: #000; z-index: 9999; display: flex; align-items: center; justify-content: center; overflow: hidden; }
            #skipBtn { position: absolute; bottom: 20px; right: 20px; padding: 8px 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 6px; cursor: pointer; z-index: 10000; font-weight: bold; }
            #staffRollContainer { width: 100%; height: 100%; overflow: hidden; position: relative; }
            .credits-list { position: absolute; top: 100%; left: 50%; transform: translateX(-50%); width: 90%; max-width: 700px; color: #e0e0e0; text-align: center; font-size: 16px; animation: scroll-up 14s linear forwards; }
            .credits-list pre { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size: 1em; line-height: 1.8; text-align: left; white-space: pre-wrap; margin: 0; }
            @keyframes scroll-up { 0% { top: 100%; } 100% { top: -100%; } }
            .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); backdrop-filter: blur(8px); z-index: 1000; display: flex; align-items: center; justify-content: center; padding: 16px; }
            .modal-content { background: var(--panel-bg); border: 1px solid var(--panel-border); border-radius: 12px; padding: 24px; width: 100%; max-width: 500px; box-shadow: 0 10px 40px rgba(0,0,0,0.5); }
            .modal-content h2 { margin-top: 0; font-size: 20px; border-bottom: 1px solid var(--accent-color); padding-bottom: 8px; margin-bottom: 16px; }
            #hamburger-icon { position: fixed; top: 20px; right: 20px; width: 30px; height: 22px; cursor: pointer; z-index: 1002; display: flex; flex-direction: column; justify-content: space-between; }
            #hamburger-icon span { display: block; height: 3px; width: 100%; background: #e6eef8; border-radius: 3px; transition: all 0.3s ease-in-out; }
            #menu-panel { position: fixed; top: 0; right: -300px; width: 280px; height: 100%; background: var(--panel-bg); box-shadow: -5px 0 25px rgba(0,0,0,0.5); z-index: 1001; transition: right 0.4s ease-in-out; padding: 80px 20px 20px; box-sizing: border-box; }
            #menu-panel.open { right: 0; }
            .menu-item { padding: 15px 10px; border-bottom: 1px solid var(--panel-border); color: #e6eef8; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
            .feedback-popup { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: clamp(32px, 5vw, 48px); font-weight: 900; color: #fff; text-shadow: 0 0 10px #FFD166, 0 0 20px #FF6B6B, 0 0 30px #06D6A0; pointer-events: none; z-index: 100; white-space: nowrap; animation: feedback-popup-animation 1.2s ease-out forwards; }
            @keyframes feedback-popup-animation { 0% { opacity: 1; transform: translate(-50%, -50%) scale(0.8); } 20% { opacity: 1; transform: translate(-50%, -60%) scale(1.2); } 100% { opacity: 0; transform: translate(-50%, -150%) scale(1.2); } }
            #loadComplete h1 { font-size: 48px; font-weight: 800; color: #fff; letter-spacing: 0.1em; text-shadow: 0 0 10px #4D96FF, 0 0 20px #4D96FF; margin-bottom: 8px; }
            .fade-in { animation: fade-in 1s ease-out forwards; }
            @keyframes fade-in { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
            .fade-out { animation: fade-out 1s ease-in forwards; }
            @keyframes fade-out { from { opacity: 1; } to { opacity: 0; } }
            .modal-content ul { padding-left: 20px; line-height: 1.7; }
            .modal-content .sub-header { font-weight: bold; margin-top: 16px; margin-bottom: 4px; color: #a0b0d0; }
            .modal-footer { text-align: right; margin-top: 24px; }
            .password-input, .cheat-input { width: 100%; padding: 10px; border-radius: 6px; background: rgba(0,0,0,0.3); border: 1px solid var(--panel-border); color: #fff; font-size: 16px; margin-top: 8px; box-sizing: border-box; }
            .menu-item:hover { background: rgba(138, 43, 226, 0.2); }
            .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
            .switch input { opacity: 0; width: 0; height: 0; }
            .slider { position: absolute; cursor: pointer; inset: 0; background-color: #334155; transition: .4s; border-radius: 28px; }
            .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
            input:checked + .slider { background-color: var(--accent-color); }
            input:checked + .slider:before { transform: translateX(22px); }
            #qrcode { display: flex; justify-content: center; margin: 20px 0; background: white; padding: 10px; border-radius: 8px; }
            .url-container { display: flex; gap: 8px; }
            .url-input { flex-grow: 1; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid var(--panel-border); color: #e6eef8; border-radius: 6px; }
            #key-config-list { display: flex; flex-direction: column; gap: 12px; margin-top: 16px; }
            .key-config-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: rgba(0,0,0,0.2); border-radius: 6px; }
            .key-config-item .action-label { color: var(--text-secondary); font-weight: 500; }
            .key-config-item .key-display { background: rgba(0,0,0,0.4); padding: 6px 16px; border-radius: 4px; border: 1px solid var(--panel-border); min-width: 80px; text-align: center; cursor: pointer; transition: all 0.2s; }
            .key-config-item .key-display:hover { border-color: var(--accent-color); }
            .key-config-item .key-display.listening { border-color: #FFD166; color: #FFD166; box-shadow: 0 0 10px #FFD166; }
            #fake-translator { position: fixed; inset: 0; background: #fff; z-index: 10000; color: #202124; font-family: 'Roboto', 'Noto Sans JP', sans-serif; display: flex; flex-direction: column; }
            .translator-header { display: flex; justify-content: flex-start; align-items: center; padding: 12px 24px; border-bottom: 1px solid #e0e0e0; flex-shrink: 0; }
            .translator-logo { font-size: 22px; font-weight: 500; color: #5f6368; display: flex; align-items: center; gap: 8px; }
            .translator-main { display: flex; flex-direction: column; flex-grow: 1; padding: 24px; }
            .translator-lang-bar { display: flex; gap: 8px; margin-bottom: 8px; }
            .lang-btn { padding: 8px 16px; border: none; background: none; cursor: pointer; font-weight: 500; font-size: 14px; color: #5f6368; border-bottom: 2px solid transparent; }
            .lang-btn.active { color: #1a73e8; border-bottom-color: #1a73e8; }
            .translator-body { display: grid; grid-template-columns: 1fr auto 1fr; gap: 16px; flex-grow: 1; border: 1px solid #dadce0; border-radius: 8px; padding: 16px; }
            .translator-panel { display: flex; flex-direction: column; }
            .translator-textarea { flex-grow: 1; resize: none; border: none; padding: 0; font-size: 24px; font-family: 'Roboto', 'Noto Sans JP', sans-serif; box-sizing: border-box; background: none; color: #202124; }
            .translator-textarea:focus { outline: none; }
            .translator-divider { width: 1px; background: #dadce0; }
            #dev-hud { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: limegreen; font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; padding: 10px; border-radius: 8px; z-index: 9999; pointer-events: none; white-space: pre; line-height: 1.4; display: flex; gap: 20px; }
            .fps-good { color: #86efac; } .fps-warn { color: #fde047; } .fps-bad { color: #f87171; }
            .dev-controls-panel { display: flex; flex-direction: column; gap: 4px; pointer-events: auto; }
            .dev-controls-panel button { background: rgba(120, 255, 120, 0.2); border: 1px solid limegreen; color: limegreen; font-family: monospace; cursor: pointer; padding: 2px 6px; border-radius: 4px; }
            .dev-controls-panel button:hover { background: rgba(120, 255, 120, 0.4); }
            #dev-console { position: fixed; bottom: 10px; right: 10px; left: auto; width: calc(100% - 20px); max-width: 600px; height: 100px; background: rgba(10,10,20,0.8); border: 1px solid var(--panel-border); border-radius: 8px; z-index: 9998; overflow-y: auto; padding: 8px; font-family: monospace; font-size: 11px; color: #ccc; pointer-events: none; }
            #dev-console .log-error { color: #ff8080; } #dev-console .log-warn { color: #fde047; }
            #sokohara-record { position: fixed; top: 20px; left: 50%; background: linear-gradient(45deg, #ffd700, #ff8c00); color: #000; padding: 12px 24px; border-radius: 10px; font-size: 18px; font-weight: bold; z-index: 1005; box-shadow: 0 5px 20px rgba(0,0,0,0.4); text-shadow: 1px 1px 2px rgba(255,255,255,0.3); }
            @keyframes fade-in-then-out { 0% { opacity: 0; transform: translate(-50%, -80px); } 15% { opacity: 1; transform: translate(-50%, 0); } 85% { opacity: 1; transform: translate(-50%, 0); } 100% { opacity: 0; transform: translate(-50%, -80px); } }
            
            @media (max-width: 1200px) {
                .app.vs-cpu-mode { grid-template-columns: 1fr; grid-template-rows: auto auto auto; }
                .app.vs-cpu-mode #cpu-container { display: none; }
                .app.vs-cpu-mode .side-panel { flex-direction: row; justify-content: space-around; }
            }
            @media (max-width: 980px) {
                .app, .app.vs-cpu-mode, .app.single-player-mode { grid-template-columns: 1fr; grid-template-rows: auto auto auto; gap: 16px; }
                .side-panel.left { order: 2; }
                .game-container { order: 1; }
                .side-panel.right { order: 3; }
                #cpu-container { display: none !important; }
                .side-panel { flex-direction: row; justify-content: space-around; }
                .panel-card { flex: 1; }
                .title { font-size: 20px; }
                #dev-hud { font-size: 10px; flex-direction: column; }
                #dev-console { max-width: 100%; height: 80px; }
            }
        </style>
    </head>
    <body>
        <div id="dev-hud" class="hidden"></div>
        <div id="dev-console" class="hidden"></div>
        <div id="sokohara-record" class="hidden">底原永和の最高記録: レベル21 98400点</div>
        <div class="container">
            <div id="loader">
                <button id="skipBtn">スキップ</button>
                <div id="staffRollContainer">
                    <div class="credits-list">
                        <pre>プロデューサー .................. 底原永和
ディレクター .................... 底原永和
エグゼクティブプロデューサー .... 底原永和
アシスタントプロデューサー ...... 底原永和
デザイン ........................ 底原永和
シナリオ ........................ 底原永和
レベルデザイン .................. 底原永和
バランス調整 .................... 底原永和
UI/UXデザイン ................... 底原永和
プログラムリード ................ 底原永和
エンジンプログラマー ............ 底原永和
ネットワークプログラマー ........ 底原永和
AIプログラマー .................. 底原永和
ツールプログラマー .............. 底原永和
サウンドプログラマー ............ 底原永和
グラフィックプログラマー ........ 底原永和
アートディレクター .............. 底原永和
キャラクターデザイナー .......... 底原永和
モンスターデザイナー ............ 底原永和
背景デザイナー .................. 底原永和
UIデザイナー .................... 底原永和
2Dアーティスト .................. 底原永和
3Dモデラー ...................... 底原永和
リガー .......................... 底原永和
アニメーター .................... 底原永和
モーションキャプチャー .......... 底原永和
VFXアーティスト ................ 底原永和
ライティングアーティスト ........ 底原永和
テクスチャーアーティスト ........ 底原永和
サウンドディレクター ............ 底原永和
作曲 ............................ 底原永和
効果音制作 ...................... 底原永和
ボイス収録 ...................... 底原永和
ミキシング ...................... 底原永和
QAマネージャー .................. 底原永和
QAリーダー ...................... 底原永和
QAテスター ...................... 底原永和
ローカライズディレクター ........ 底原永和
翻訳 ............................ 底原永和
ローカライズテスター ............ 底原永和
マーケティングマネージャー ...... 底原永和
PR .............................. 底原永和
コミュニティマネージャー ........ 底原永和
公式サイト運営 .................. 底原永和
スペシャルサンクス .............. 底原永和
</pre>
                    </div>
                </div>
                <div id="loadComplete" class="hidden">
                    <h1>楽しいね</h1>
                </div>
            </div>
            <div id="initial-setup-container">
                <div id="animation-mode-screen" class="hidden">
                    <div class="overlay-content">
                        <h2>アニメーション設定</h2>
                        <p>体験を選択してください</p>
                    </div>
                    <div class="overlay-footer">
                        <button class="btn" data-animation-mode="normal">通常アニメーション</button>
                        <button class="btn" data-animation-mode="low">低アニメーションモード</button>
                    </div>
                </div>
            </div>
            <div id="hamburger-icon" class="hidden">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <div id="menu-panel">
                <div class="menu-item" id="menu-restart-btn">
                    <span>やり直す</span>
                </div>
                <div class="menu-item">
                    <span>サウンド</span>
                    <label class="switch">
                        <input type="checkbox" id="sound-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="menu-item" id="menu-key-config-btn">
                    <span>キー設定</span>
                </div>
                <div class="menu-item" id="menu-share-btn">
                    <span>共有する</span>
                </div>
                <div class="menu-item" id="menu-cheat-btn">
                    <span>コード入力</span>
                </div>
                <div class="menu-item" id="menu-dev-mode-btn">
                    <span>開発者モード</span>
                </div>
            </div>
            <div class="app hidden single-player-mode" id="appContainer">
                <aside class="side-panel left">
                    <div class="panel-card">
                        <h3>HOLD</h3>
                        <div class="preview-box" id="holdContainer"></div>
                    </div>
                    <div class="panel-card">
                        <h3>SCORE</h3>
                        <div class="score-grid">
                            <div class="scorebox">
                                <span>HIGH</span>
                                <span id="highScore">0</span>
                            </div>
                            <div class="scorebox">
                                <span>SCORE</span>
                                <span id="currentScore">0</span>
                            </div>
                            <div class="scorebox">
                                <span>LINES</span>
                                <span id="lines">0</span>
                            </div>
                            <div class="scorebox">
                                <span>LEVEL</span>
                                <span id="level">1</span>
                            </div>
                        </div>
                        <div class="controls-panel">
                            <button class="btn" id="pauseButton">停止</button>
                            <button class="btn ghost" id="forceRestartBtn">やり直す</button>
                        </div>
                    </div>
                    <div class="panel-card hidden" id="modeInfoPanel">
                        <h3 id="modeInfoTitle">MODE INFO</h3>
                        <div class="score-grid" id="modeInfoContent"></div>
                    </div>
                </aside>
                <main class="game-container" id="player-game-container">
                    <div class="game-header">
                        <div class="title">ブロック落とし</div>
                        <div class="meta-box" id="scoreBox">Score: 0</div>
                    </div>
                    <div class="board-wrap">
                        <div id="countdown" class="hidden"></div>
                        <div id="game-overlay">
                            <div id="start-screen">
                                <div class="overlay-content">
                                    <h2>ブロック落とし</h2>
                                    <p>モードを選択してください</p>
                                </div>
                                <div class="overlay-footer">
                                    <button class="btn" data-mode="TRAINING">トレーニング</button>
                                    <button class="btn" data-mode="SPRINT">40ライン スプリント</button>
                                    <button class="btn" data-mode="ULTRA">3分 ウルトラ</button>
                                    <div class="cpu-select-container">
                                        <button class="btn" id="vs-cpu-btn">VS CPU ▼</button>
                                        <div class="cpu-level-dropdown" id="vs-cpu-select">
                                            <button class="btn" data-mode="VS_CPU_1">LV.1</button>
                                            <button class="btn" data-mode="VS_CPU_2">LV.2</button>
                                            <button class="btn" data-mode="VS_CPU_3">LV.3</button>
                                            <button class="btn" data-mode="VS_CPU_4">LV.4</button>
                                            <button class="btn" data-mode="VS_CPU_5">LV.5</button>
                                            <button class="btn" data-mode="VS_CPU_6">LV.6</button>
                                            <button class="btn" data-mode="VS_CPU_7">LV.7</button>
                                            <button class="btn" data-mode="VS_CPU_8">LV.8</button>
                                            <button class="btn" data-mode="VS_CPU_9">LV.9</button>
                                        </div>
                                    </div>
                                    <div class="cpu-select-container">
                                        <button class="btn" id="ultra-vs-cpu-btn">ウルトラ VS CPU ▼</button>
                                        <div class="cpu-level-dropdown" id="ultra-vs-cpu-select">
                                            <button class="btn" data-mode="ULTRA_VS_CPU_1">LV.1</button>
                                            <button class="btn" data-mode="ULTRA_VS_CPU_2">LV.2</button>
                                            <button class="btn" data-mode="ULTRA_VS_CPU_3">LV.3</button>
                                            <button class="btn" data-mode="ULTRA_VS_CPU_4">LV.4</button>
                                            <button class="btn" data-mode="ULTRA_VS_CPU_5">LV.5</button>
                                            <button class="btn" data-mode="ULTRA_VS_CPU_6">LV.6</button>
                                            <button class="btn" data-mode="ULTRA_VS_CPU_7">LV.7</button>
                                            <button class="btn" data-mode="ULTRA_VS_CPU_8">LV.8</button>
                                            <button class="btn" data-mode="ULTRA_VS_CPU_9">LV.9</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div id="gameover-screen" class="hidden">
                                <div class="overlay-content">
                                    <h2 id="gameover-title"></h2>
                                    <p id="gameover-result"></p>
                                </div>
                                <div class="overlay-footer">
                                    <button class="btn" id="restartButton">もう一度プレイ</button>
                                </div>
                            </div>
                            <div id="pause-screen" class="hidden">
                                <div class="overlay-content">
                                    <h2>PAUSED</h2>
                                    <p>一時停止...</p>
                                </div>
                                <div class="overlay-footer">
                                    <button class="btn" id="resumeButton">ゲームに戻る</button>
                                </div>
                            </div>
                        </div>
                        <div class="board" id="board"></div>
                    </div>
                </main>
                <main id="cpu-container" class="game-container hidden" style="transform: scale(0.85); transform-origin: top center;">
                    <div class="game-header">
                        <div class="title">CPU</div>
                        <div class="meta-box" id="cpu-level-box">AI</div>
                    </div>
                    <div class="board-wrap">
                        <div class="board" id="cpu-board"></div>
                    </div>
                </main>
                <aside class="side-panel right">
                    <div class="panel-card">
                        <h3>NEXT</h3>
                        <div class="preview-box" id="nextContainer"></div>
                    </div>
                    <div class="panel-card">
                        <h3>CONTROLS</h3>
                        <div class="note">
                            → : 右移動<br>
                            ← : 左移動<br>
                            ↑ : ハードドロップ<br>
                            ↓ : ソフトドロップ<br>
                            Z : 左回転<br>
                            X : 右回転<br>
                            C : ホールド<br>Esc : 停止
                        </div>
                    </div>
                    <div class="panel-card">
                        <div class="note" style="text-align: center;">
                            <a href="https://forms.gle/Twv47c7AG9uAM2fG6" target="_blank" rel="noopener noreferrer" style="color: var(--text-secondary);">フィードバック</a>
                            <br>ヒント: Enterで偽装モード
                        </div>
                    </div>
                </aside>
            </div>
            <div id="noticeModal" class="modal-overlay hidden">
                <div class="modal-content">
                    <h2>アップデート情報</h2>
                    <div class="sub-header">今回の修正・追加</div>
                    <ul>
                        <li>ハイスコアがモード別に保存されるようになりました。</li>
                        <li>低アニメーションモードを追加しました。</li>
                        <li>開発者モードを追加しました。（メニューから）</li>
                    </ul>
                    <div class="modal-footer">
                        <button class="btn" id="closeNoticeBtn">閉じる</button>
                    </div>
                </div>
            </div>
            <div id="keyConfigModal" class="modal-overlay hidden">
                <div class="modal-content">
                    <h2>キー設定</h2>
                    <div id="key-config-list"></div>
                    <div class="modal-footer">
                        <button class="btn ghost" id="resetKeysBtn">初期設定に戻す</button>
                        <button class="btn" id="saveKeysBtn">保存して閉じる</button>
                    </div>
                </div>
            </div>
            <div id="cheatCodeModal" class="modal-overlay hidden">
                <div class="modal-content">
                    <h2>コード入力</h2>
                    <p class="note">コードを入力してください。</p>
                    <input type="password" id="cheatInput" class="cheat-input">
                    <div class="modal-footer">
                        <button class="btn" id="submitCheatBtn">実行</button>
                        <button class="btn ghost" id="closeCheatBtn">キャンセル</button>
                    </div>
                </div>
            </div>
            <div id="devPasswordModal" class="modal-overlay hidden">
                <div class="modal-content">
                    <h2>開発者モード</h2>
                    <p class="note">パスワードを入力してください。</p>
                    <input type="password" id="devPasswordInput" class="password-input">
                    <div class="modal-footer">
                        <button class="btn" id="submitDevPasswordBtn">認証</button>
                        <button class="btn ghost" id="closeDevPasswordBtn">キャンセル</button>
                    </div>
                </div>
            </div>
            <div id="shareModal" class="modal-overlay hidden">
                <div class="modal-content">
                    <h2>共有</h2>
                    <div id="qrcode"></div>
                    <p class="note center">QRコードをスキャンするか、URLをコピー</p>
                    <div class="url-container">
                        <input type="text" id="urlInput" class="url-input" readonly>
                        <button class="btn" id="copyUrlBtn">コピー</button>
                    </div>
                    <div class="modal-footer">
                        <button class="btn" id="closeShareBtn">閉じる</button>
                    </div>
                </div>
            </div>
            <div id="fake-translator" class="hidden">
                <header class="translator-header">
                    <div class="translator-logo">
                        <svg focusable="false" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                            <path d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path>
                        </svg>
                        <span>翻訳</span>
                    </div>
                </header>
                <main class="translator-main">
                    <div class="translator-lang-bar">
                        <button class="lang-btn active">日本語</button>
                        <button class="lang-btn">英語</button>
                    </div>
                    <div class="translator-body">
                        <div class="translator-panel">
                            <textarea id="translator-input" class="translator-textarea" placeholder="テキストを入力"></textarea>
                        </div>
                        <div class="translator-divider"></div>
                        <div class="translator-panel">
                            <textarea id="translator-output" class="translator-textarea" readonly></textarea>
                        </div>
                    </div>
                </main>
            </div>
        </div>
        <audio id="bgmAudio" src="bgm.mp3" loop></audio>
        <audio id="pushAudio" src="push.mp3"></audio>
        <audio id="delAudio" src="del.mp3"></audio>
        <script>
            let lowAnimationMode = false;
            
            window.addEventListener('DOMContentLoaded', () => {
                const loader = document.getElementById('loader');
                const skipBtn = document.getElementById('skipBtn');
                const animationScreen = document.getElementById('animation-mode-screen');
                const initialSetupContainer = document.getElementById('initial-setup-container');

                const showAnimationChoice = () => {
                    if (loader.parentNode) {
                        loader.classList.add('fade-out');
                        loader.addEventListener('animationend', () => {
                            if (loader.parentNode) loader.remove();
                        }, { once: true });
                        
                        initialSetupContainer.classList.remove('hidden');
                        animationScreen.classList.remove('hidden');
                        animationScreen.classList.add('fade-in');

                        document.querySelectorAll('[data-animation-mode]').forEach(btn => {
                            btn.addEventListener('click', (e) => {
                                lowAnimationMode = e.target.dataset.animationMode === 'low';
                                initialSetupContainer.classList.add('hidden');
                                showUpdateInfo();
                            }, { once: true });
                        });
                    }
                };

                const skipLoading = () => {
                    clearTimeout(startTimer);
                    showAnimationChoice();
                };

                let startTimer = setTimeout(showAnimationChoice, 14000);
                skipBtn.addEventListener('click', skipLoading);
            });

            function showUpdateInfo() {
                const noticeModal = document.getElementById('noticeModal');
                noticeModal.classList.remove('hidden');
                
                document.getElementById('closeNoticeBtn').addEventListener('click', () => {
                    noticeModal.classList.add('hidden');
                    showSokoharaRecord();
                }, { once: true });
            }

            function showSokoharaRecord() {
                const recordEl = document.getElementById('sokohara-record');
                recordEl.classList.remove('hidden');
                recordEl.style.animation = 'fade-in-then-out 5s ease-out forwards';
                recordEl.addEventListener('animationend', () => {
                    recordEl.classList.add('hidden');
                    recordEl.style.animation = '';
                    startMainApp();
                }, { once: true });
            }

            function startMainApp() {
                const appContainer = document.getElementById('appContainer');
                const hamburgerIcon = document.getElementById('hamburger-icon');
                appContainer.classList.remove('hidden');
                appContainer.classList.add('fade-in');
                hamburgerIcon.classList.remove('hidden');
                initGame();
            }

            const devHUD = {
                enabled: false,
                elements: { hud: document.getElementById('dev-hud'), console: document.getElementById('dev-console'), },
                perf: { lastTime: performance.now(), frames: 0, fps: 0, frameTime: 0, cpuUsage: 0, memory: 'N/A', drawCalls: 0 },
                progress: { round: 'N/A', level: 1, lines: 0, score: 0, playTime: 0, startTime: performance.now(), isOver: false, mode: 'N/A' },
                graphics: { spriteCount: 0, canvasSize: '0x0', devicePixelRatio: window.devicePixelRatio || 1 },
                input: { lastKey: 'N/A', history: [], mouse: { x: 0, y: 0 }, clicks: 0 },
                data: { objectCount: 0, currentPiece: 'None', nextPiece: 'None', heldPiece: 'None' },
                system: { userAgent: navigator.userAgent.substring(0, 40) + '...', windowSize: `${window.innerWidth}x${window.innerHeight}`, refreshRate: 'N/A' },
                debug: { flags: { devMode: false, lowAnim: false } }
            };

            function updateDevHUD() {
                if (!devHUD.enabled) { requestAnimationFrame(updateDevHUD); return; }
                const now = performance.now();
                const delta = now - devHUD.perf.lastTime;
                devHUD.perf.frameTime = delta;
                devHUD.perf.lastTime = now;
                devHUD.perf.frames++;
                if (now > (devHUD.perf.lastCalcTime || 0) + 1000) {
                    devHUD.perf.fps = devHUD.perf.frames;
                    devHUD.perf.frames = 0;
                    devHUD.perf.lastCalcTime = now;
                    devHUD.system.refreshRate = `${devHUD.perf.fps} Hz (est.)`;
                }
                const targetFrameTime = 1000 / 60;
                devHUD.perf.cpuUsage = Math.min(100, (devHUD.perf.frameTime / targetFrameTime) * 100);
                devHUD.perf.memory = performance.memory ? `${(performance.memory.usedJSHeapSize / 1048576).toFixed(2)} MB` : 'N/A';
                devHUD.progress.playTime = (now - devHUD.progress.startTime) / 1000;
                const fpsClass = devHUD.perf.fps >= 55 ? 'fps-good' : devHUD.perf.fps >= 30 ? 'fps-warn' : 'fps-bad';
                devHUD.elements.hud.innerHTML = `<div>--[ 📊 PERFORMANCE ]---------<br>FPS : <span class="${fpsClass}">${devHUD.perf.fps}</span><br>Frame Time : ${devHUD.perf.frameTime.toFixed(2)} ms<br>CPU Usage : ${devHUD.perf.cpuUsage.toFixed(1)} %<br>Memory : ${devHUD.perf.memory}<br>Draw Calls : ${devHUD.perf.drawCalls}<br><br>--[ 🚀 PROGRESS ]------------<br>Mode : ${devHUD.progress.mode}<br>Score : ${devHUD.progress.score}<br>Level : ${devHUD.progress.level}<br>Lines : ${devHUD.progress.lines}<br>Time : ${devHUD.progress.playTime.toFixed(1)} s<br>Finished : ${devHUD.progress.isOver}<br><br>--[ 🧩 PIECE DATA ]----------<br>Current : ${devHUD.data.currentPiece}<br>Next : ${devHUD.data.nextPiece}<br>Hold : ${devHUD.data.heldPiece}</div><div>--[ 🖥 GRAPHICS ]------------<br>Sprites : ${devHUD.graphics.spriteCount}<br>Canvas : ${devHUD.graphics.canvasSize}<br>DPR : ${devHUD.graphics.devicePixelRatio.toFixed(2)}<br><br>--[ 🔍 INPUT ]----------------<br>Last Key : ${devHUD.input.lastKey}<br>History : [${devHUD.input.history.join(', ')}]<br>Mouse/Touch: ${devHUD.input.mouse.x}, ${devHUD.input.mouse.y}<br>Clicks : ${devHUD.input.clicks}<br><br>--[ ⚙️ SYSTEM ]--------------<br>User Agent : ${devHUD.system.userAgent}<br>Window Size: ${devHUD.system.windowSize}<br><br>--[ 🐞 DEBUG ]----------------<br>Low Anim : ${devHUD.debug.flags.lowAnim ? 'ON' : 'OFF'}<br><div class="dev-controls-panel"><button data-action="set-score">Set Score</button></div></div>`;
                devHUD.perf.drawCalls = 0;
                requestAnimationFrame(updateDevHUD);
            }
            function logToDevConsole(message, type = 'log') { if (!devHUD.enabled) return; const p = document.createElement('p'); p.className = `log-${type}`; p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`; devHUD.elements.console.appendChild(p); devHUD.elements.console.scrollTop = devHUD.elements.console.scrollHeight; }
            window.addEventListener('keydown', e => { devHUD.input.lastKey = e.key; devHUD.input.history.unshift(e.key); if (devHUD.input.history.length > 5) devHUD.input.history.pop(); });
            requestAnimationFrame(updateDevHUD);

            function initGame() {
                const COLS = 10, ROWS = 20;
                const TETROMINOS = {
                    'I': { shape: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], color: '#4D96FF', name: 'I' },
                    'O': { shape: [[1, 1], [1, 1]], color: '#FFD166', name: 'O' },
                    'T': { shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], color: '#9B5DE5', name: 'T' },
                    'S': { shape: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], color: '#06D6A0', name: 'S' },
                    'Z': { shape: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], color: '#FF6B6B', name: 'Z' },
                    'J': { shape: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], color: '#FF7AB6', name: 'J' },
                    'L': { shape: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], color: '#f08a5d', name: 'L' }
                };
                const POINTS = { 1: 100, 2: 300, 3: 500, 4: 800 };
                const WALL_KICK_DATA = {
                    'J': [[[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]], [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]], [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]]],
                    'L': [[[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]], [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]], [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]]],
                    'S': [[[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]], [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]], [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]]],
                    'Z': [[[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]], [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]], [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]]],
                    'T': [[[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]], [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]], [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]], [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]]],
                    'I': [[[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]], [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]], [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]], [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]]]
                };

                const ATTACK_LINES = { 1: 1, 2: 2, 3: 3, 4: 5 };
                const COMBO_ATTACK = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6];
                const CPU_LEVELS = { 1: { thinkTime: 700, actionInterval: 150, mistakeChance: 0.5, weights: { AGG_H: -0.4, COMP_L: 0.6, HOLES: -0.3, BUMP: -0.1, WELLS: -0.2 } }, 2: { thinkTime: 600, actionInterval: 130, mistakeChance: 0.4, weights: { AGG_H: -0.45, COMP_L: 0.7, HOLES: -0.4, BUMP: -0.15, WELLS: -0.25 } }, 3: { thinkTime: 500, actionInterval: 110, mistakeChance: 0.3, weights: { AGG_H: -0.5, COMP_L: 0.8, HOLES: -0.5, BUMP: -0.2, WELLS: -0.3 } }, 4: { thinkTime: 400, actionInterval: 100, mistakeChance: 0.2, weights: { AGG_H: -0.5, COMP_L: 0.9, HOLES: -0.6, BUMP: -0.2, WELLS: -0.3 } }, 5: { thinkTime: 300, actionInterval: 90, mistakeChance: 0.1, weights: { AGG_H: -0.55, COMP_L: 1.0, HOLES: -0.7, BUMP: -0.25, WELLS: -0.35 } }, 6: { thinkTime: 200, actionInterval: 80, mistakeChance: 0.05, weights: { AGG_H: -0.55, COMP_L: 1.1, HOLES: -0.8, BUMP: -0.25, WELLS: -0.35 } }, 7: { thinkTime: 150, actionInterval: 70, mistakeChance: 0.02, weights: { AGG_H: -0.6, COMP_L: 1.2, HOLES: -0.9, BUMP: -0.3, WELLS: -0.4 } }, 8: { thinkTime: 100, actionInterval: 60, mistakeChance: 0.01, weights: { AGG_H: -0.6, COMP_L: 1.2, HOLES: -0.9, BUMP: -0.3, WELLS: -0.4 } }, 9: { thinkTime: 50, actionInterval: 50, mistakeChance: 0, weights: { AGG_H: -0.6, COMP_L: 1.2, HOLES: -0.9, BUMP: -0.3, WELLS: -0.4 } } };
                
                const appContainer = document.getElementById('appContainer'), playerGameContainer = document.getElementById('player-game-container'), boardEl = document.getElementById('board'), scoreBox = document.getElementById('scoreBox'), highScoreEl = document.getElementById('highScore'), currentScoreEl = document.getElementById('currentScore'), forceRestartBtn = document.getElementById('forceRestartBtn'), linesEl = document.getElementById('lines'), levelEl = document.getElementById('level'), nextContainer = document.getElementById('nextContainer'), holdContainer = document.getElementById('holdContainer'), gameOverlay = document.getElementById('game-overlay'), startScreen = document.getElementById('start-screen'), gameoverScreen = document.getElementById('gameover-screen'), gameoverTitle = document.getElementById('gameover-title'), gameoverResult = document.getElementById('gameover-result'), restartButton = document.getElementById('restartButton'), pauseScreen = document.getElementById('pause-screen'), resumeButton = document.getElementById('resumeButton'), pauseButton = document.getElementById('pauseButton'), modeInfoPanel = document.getElementById('modeInfoPanel'), modeInfoTitle = document.getElementById('modeInfoTitle'), modeInfoContent = document.getElementById('modeInfoContent'), countdownEl = document.getElementById('countdown');
                const cpuContainer = document.getElementById('cpu-container'), cpuBoardEl = document.getElementById('cpu-board'), cpuLevelBox = document.getElementById('cpu-level-box');
                const vsCpuBtn = document.getElementById('vs-cpu-btn'), vsCpuSelect = document.getElementById('vs-cpu-select');
                const ultraVsCpuBtn = document.getElementById('ultra-vs-cpu-btn'), ultraVsCpuSelect = document.getElementById('ultra-vs-cpu-select');
                const hamburgerIcon = document.getElementById('hamburger-icon'), menuPanel = document.getElementById('menu-panel'), menuRestartBtn = document.getElementById('menu-restart-btn'), soundToggle = document.getElementById('sound-toggle'), menuCheatBtn = document.getElementById('menu-cheat-btn');

                let player = {};
                let cpu = null;
                
                let pieceBag, sharedNextPiece, isPaused, isOver, gameMode, cpuLevel, bestScores = {}, keys = {};
                let lastTime = 0, animationFrameId, countdownInterval, cpuActionInterval, gameTimer, gameInterval;
                let dasTimer, arrTimer, softDropTimer, keyMap, actionToChange = null;

                const defaultKeyMap = { moveLeft: 'ArrowLeft', moveRight: 'ArrowRight', softDrop: 'ArrowDown', hardDrop: 'ArrowUp', rotateLeft: 'z', rotateRight: 'x', hold: 'c' };
                const actionLabels = { moveLeft: '左移動', moveRight: '右移動', softDrop: 'ソフトドロップ', hardDrop: 'ハードドロップ', rotateLeft: '左回転', rotateRight: '右回転', hold: 'ホールド' };
                const LOCK_DELAY = 500, LANDING_RESET_LIMIT = 15, DAS_DELAY = 160, ARR_DELAY = 30, SOFT_DROP_DELAY = 50;

                const createPlayerState = (isCPU = false) => ({
                    board: Array(ROWS).fill(0).map(() => Array(COLS).fill(null)),
                    currentPiece: null,
                    heldPiece: null,
                    canHold: true,
                    score: 0,
                    lines: 0,
                    level: 1,
                    combo: 0,
                    isOver: false,
                    isLanded: false,
                    landingResets: 0,
                    lockDelayTimer: null,
                    isCPU,
                    pendingGarbage: 0,
                    dropInterval: 1000,
                    dropCounter: 0,
                    ai: { actionQueue: [], isThinking: false }
                });


                function init() {
                    bestScores = loadBestScores();
                    loadKeyMap();
                    isPaused = true;
                    isOver = true;
                    setupUI();
                    createEmptyBoard(boardEl);
                    if(cpuBoardEl) createEmptyBoard(cpuBoardEl);

                    document.querySelectorAll('#start-screen .btn[data-mode]').forEach(btn => btn.addEventListener('click', (e) => startGame(e.target.dataset.mode)));
                    vsCpuBtn.addEventListener('click', () => { ultraVsCpuSelect.classList.remove('open'); vsCpuSelect.classList.toggle('open'); });
                    ultraVsCpuBtn.addEventListener('click', () => { vsCpuSelect.classList.remove('open'); ultraVsCpuSelect.classList.toggle('open'); });

                    restartButton.addEventListener('click', showStartScreen);
                    pauseButton.addEventListener('click', togglePause);
                    resumeButton.addEventListener('click', togglePause);
                    forceRestartBtn.addEventListener('click', () => { if (!isOver && confirm('本当に現在のゲームを終了し、モード選択に戻りますか？')) { showStartScreen(); } else if (isOver) { showStartScreen(); } });
                    menuRestartBtn.addEventListener('click', () => { if (isOver || isPaused || confirm('本当に現在のゲームを終了し、モード選択に戻りますか？')) { showStartScreen(); } menuPanel.classList.remove('open'); });
                    
                    setupKeyHandlers();
                    setupExtraFeatures();
                    setupKeyConfigModal();
                    setupDevMode();
                }

                function startGame(mode) {
                    gameMode = mode;
                    cpuLevel = 0;
                    if (gameMode.startsWith('VS_CPU') || gameMode.startsWith('ULTRA_VS_CPU')) {
                        cpuLevel = parseInt(mode.split('_').pop(), 10);
                        if(gameMode.startsWith('ULTRA_VS_CPU')) {
                            gameMode = 'ULTRA_VS_CPU';
                        } else {
                            gameMode = 'VS_CPU';
                        }
                        cpuLevelBox.textContent = `LV.${cpuLevel}`;
                    }

                    if (gameMode === 'VS_CPU' || gameMode === 'ULTRA_VS_CPU') {
                        appContainer.classList.remove('single-player-mode');
                        appContainer.classList.add('vs-cpu-mode');
                        cpuContainer.classList.remove('hidden');
                    } else {
                        appContainer.classList.remove('vs-cpu-mode');
                        appContainer.classList.add('single-player-mode');
                        cpuContainer.classList.add('hidden');
                    }

                    startScreen.classList.add('hidden');
                    gameoverScreen.classList.add('hidden');
                    pauseScreen.classList.add('hidden');
                    appContainer.classList.remove('game-inactive-blur');

                    let count = 3;
                    countdownEl.textContent = count;
                    countdownEl.classList.remove('hidden');
                    if (countdownInterval) clearInterval(countdownInterval);
                    countdownInterval = setInterval(() => {
                        count--;
                        if (count > 0) { countdownEl.textContent = count; } 
                        else { clearInterval(countdownInterval); countdownEl.classList.add('hidden'); startActualGame(); }
                    }, 1000);
                }

                function startActualGame() {
                    gameOverlay.classList.add('hidden');
                    isPaused = false;
                    isOver = false;
                    pauseButton.textContent = "停止";

                    player = createPlayerState();
                    cpu = (gameMode === 'VS_CPU' || gameMode === 'ULTRA_VS_CPU') ? createPlayerState(true) : null;
                    
                    pieceBag = [];
                    fillPieceBag();
                    sharedNextPiece = getNextPieceFromBag();
                    
                    spawnPiece(player);
                    if (cpu) spawnPiece(cpu);

                    if (gameInterval) clearInterval(gameInterval);
                    if (cpuActionInterval) clearInterval(cpuActionInterval);

                    if (gameMode === 'SPRINT') gameTimer = 0;
                    else if (gameMode === 'ULTRA' || gameMode === 'ULTRA_VS_CPU') gameTimer = 180;
                    
                    gameInterval = setInterval(() => {
                        if (isPaused || isOver) return;
                        if (gameMode === 'SPRINT') gameTimer++;
                        else if (gameMode === 'ULTRA' || gameMode === 'ULTRA_VS_CPU') {
                            gameTimer--;
                            if (gameTimer <= 0) { 
                                gameTimer = 0;
                                gameOver(gameMode === 'ULTRA_VS_CPU' ? (player.score > cpu.score ? cpu : player) : player);
                            }
                        }
                        updateUI();
                    }, 1000);

                    if(cpu) {
                        cpuActionInterval = setInterval(cpuGameLoop, CPU_LEVELS[cpuLevel].actionInterval);
                    }

                    updateUI();
                    lastTime = 0;
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    if(devHUD.enabled) devHUD.progress.startTime = performance.now();
                    gameLoop();
                }

                function gameLoop(time = 0) {
                    if (isOver) return;
                    animationFrameId = requestAnimationFrame(gameLoop);
                    if (isPaused) { lastTime = time; return; }

                    const deltaTime = time - lastTime;
                    lastTime = time;

                    if (!player.isOver) {
                        player.dropCounter += deltaTime;
                        if (player.dropCounter > player.dropInterval) {
                            drop(player);
                        }
                    }

                    if (cpu && !cpu.isOver) {
                        cpu.dropCounter += deltaTime;
                        if (cpu.dropCounter > cpu.dropInterval) {
                            drop(cpu);
                        }
                    }

                    draw(player, boardEl);
                    if (cpu) draw(cpu, cpuBoardEl);
                }
                
                function cpuGameLoop() {
                    if (isOver || !cpu || cpu.isOver || isPaused) return;
                    if (cpu.ai.actionQueue.length > 0) {
                        executeCpuAction();
                    } else if (!cpu.ai.isThinking) {
                        runCpuTurn(cpu);
                    }
                }

                function togglePause() {
                    if (isOver) return;
                    isPaused = !isPaused;
                    if (isPaused) {
                        gameOverlay.classList.remove('hidden');
                        pauseScreen.classList.remove('hidden');
                        pauseButton.textContent = "再開";
                        appContainer.classList.add('game-inactive-blur');
                        clearAllInputTimers();
                    } else {
                        gameOverlay.classList.add('hidden');
                        pauseButton.textContent = "停止";
                        lastTime = performance.now();
                        appContainer.classList.remove('game-inactive-blur');
                    }
                }

                function fillPieceBag() {
                    const p = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
                    for (let i = p.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [p[i], p[j]] = [p[j], p[i]]; }
                    pieceBag.push(...p);
                }

                function getNextPieceFromBag() {
                    if (pieceBag.length < 7) fillPieceBag();
                    const name = pieceBag.shift();
                    const piece = TETROMINOS[name];
                    return { ...piece, shape: JSON.parse(JSON.stringify(piece.shape)), x: Math.floor(COLS / 2) - Math.floor(piece.shape[0].length / 2) + (name === 'O' ? 1 : 0), y: name === 'I' ? -1 : 0, rotation: 0 };
                }
                
                function spawnPiece(target) {
                    if(isOver || target.isOver) return;
                    target.currentPiece = sharedNextPiece;
                    sharedNextPiece = getNextPieceFromBag();
                    resetLandingStatus(target);
                    if (!isValidMove(target.currentPiece, target.board)) {
                        gameOver(target);
                        return;
                    }
                    if (target.isCPU && !target.ai.isThinking) {
                        runCpuTurn(target);
                    }
                }
                
                function move(target, dir) {
                    if (!target.currentPiece || target.isOver) return;
                    const piece = { ...target.currentPiece, x: target.currentPiece.x + dir };
                    if (isValidMove(piece, target.board)) {
                        target.currentPiece.x += dir;
                        if(!target.isCPU) resetLandingTimerOnMove(target);
                    }
                }

                function drop(target) {
                    if (!target.currentPiece || target.isOver) return;
                    const piece = { ...target.currentPiece, y: target.currentPiece.y + 1 };
                    if (isValidMove(piece, target.board)) {
                        target.currentPiece.y++;
                        if(!target.isCPU) clearLockDelayTimer(target);
                        target.isLanded = false;
                    } else {
                        if (!target.isLanded) {
                            target.isLanded = true;
                            startLockDelayTimer(target);
                        }
                    }
                    target.dropCounter = 0;
                }

                function hardDrop(target) {
                    if (!target.currentPiece || target.isOver) return;
                    let y = target.currentPiece.y;
                    while (isValidMove({ ...target.currentPiece, y: y + 1 }, target.board)) {
                        y++;
                    }
                    if (y > target.currentPiece.y) {
                       target.currentPiece.y = y;
                       if(!target.isCPU) playHardDropAnimation(target);
                    }
                    lockPiece(target);
                }

                function rotate(target, dir) {
                    if (!target.currentPiece || target.currentPiece.name === 'O' || target.isOver) return;

                    const p = target.currentPiece;
                    const newRotation = (p.rotation + dir + 4) % 4;
                    let tempShape = p.shape;

                    if (dir === 1) tempShape = tempShape[0].map((_, c) => tempShape.map(r => r[c]).reverse());
                    else {
                        tempShape = tempShape.map(r => r.reverse());
                        tempShape = tempShape[0].map((_, c) => tempShape.map(r => r[c]));
                        tempShape = tempShape.map(r => r.reverse());
                    }

                    const kickData = WALL_KICK_DATA[p.name];
                    
                    for (let i = 0; i < 5; i++) {
                        const dx = (kickData[p.rotation][i][0]) - (kickData[newRotation][i][0]);
                        const dy = (kickData[p.rotation][i][1]) - (kickData[newRotation][i][1]);
                        const newPiece = { ...p, shape: tempShape, x: p.x + dx, y: p.y - dy };
                        
                        if (isValidMove(newPiece, target.board)) {
                            p.x += dx;
                            p.y -= dy;
                            p.shape = tempShape;
                            p.rotation = newRotation;
                            if(!target.isCPU) resetLandingTimerOnMove(target);
                            return;
                        }
                    }
                }

                function hold(target) {
                    if (!target.canHold || target.isOver) return;
                    target.canHold = false;
                    clearLockDelayTimer(target);
                    if (target.heldPiece) {
                        [target.currentPiece, target.heldPiece] = [target.heldPiece, target.currentPiece];
                        target.currentPiece.x = Math.floor(COLS / 2) - Math.floor(target.currentPiece.shape[0].length / 2) + (target.currentPiece.name === 'O' ? 1 : 0);
                        target.currentPiece.y = target.currentPiece.name === 'I' ? -1 : 0;
                        target.currentPiece.rotation = 0;
                        target.currentPiece.shape = JSON.parse(JSON.stringify(TETROMINOS[target.currentPiece.name].shape));
                        resetLandingStatus(target);
                    } else {
                        target.heldPiece = target.currentPiece;
                        spawnPiece(target);
                    }
                    if (!isValidMove(target.currentPiece, target.board)) {
                        gameOver(target);
                    }
                    if (target.isCPU) runCpuTurn(target);
                    updateUI();
                }

                function startLockDelayTimer(target) { clearLockDelayTimer(target); target.lockDelayTimer = setTimeout(() => lockPiece(target), LOCK_DELAY); }
                function clearLockDelayTimer(target) { if(target.lockDelayTimer) clearTimeout(target.lockDelayTimer); target.lockDelayTimer = null; }
                function resetLandingStatus(target) { target.isLanded = false; target.landingResets = 0; clearLockDelayTimer(target); }
                function resetLandingTimerOnMove(target) { if (target.isLanded && target.landingResets < LANDING_RESET_LIMIT) { startLockDelayTimer(target); target.landingResets++; } }

                async function lockPiece(target) {
                    if (!target.currentPiece || target.isOver) return;
                    
                    if(!target.isCPU) clearAllInputTimers();
                    
                    const piece = target.currentPiece;
                    clearLockDelayTimer(target);
                    
                    if (!isValidMove(piece, target.board)) {
                        piece.y--;
                        if (!isValidMove(piece, target.board)) { gameOver(target); return; }
                    }
                    
                    const element = target.isCPU ? cpuBoardEl : boardEl;
                    if (!lowAnimationMode) {
                      piece.shape.forEach((row, dy) => row.forEach((val, dx) => {
                        if (val) {
                          const bY = piece.y + dy, bX = piece.x + dx;
                          if (bY >= 0 && element.children[bY * COLS + bX]) {
                            const flash = document.createElement('div');
                            flash.className = 'lock-flash-effect';
                            element.children[bY * COLS + bX].appendChild(flash);
                            setTimeout(() => flash.remove(), 200);
                          }
                        }
                      }));
                    }

                    piece.shape.forEach((row, dy) => row.forEach((val, dx) => {
                        if (val) {
                            const bX = piece.x + dx, bY = piece.y + dy;
                            if (bY >= 0) target.board[bY][bX] = piece.color;
                        }
                    }));

                    target.currentPiece = null;
                    if(!target.isCPU) playSound('pushAudio');

                    const clearedLineCount = await clearLines(target);
                    let sentAttack = 0;
                    if (clearedLineCount > 0) {
                        target.combo++;
                        sentAttack = (ATTACK_LINES[clearedLineCount] || 0) + (COMBO_ATTACK[target.combo] || Math.max(...COMBO_ATTACK));
                    } else {
                        target.combo = 0;
                    }

                    if (gameMode === 'VS_CPU') {
                        const opponent = target.isCPU ? player : cpu;
                        let garbageToTake = target.pendingGarbage - sentAttack;
                        if (garbageToTake > 0) {
                            const garbageAmount = Math.min(1, garbageToTake); 
                            setTimeout(() => addGarbageLines(target, garbageAmount), 500); 
                            target.pendingGarbage -= garbageAmount;
                        } else {
                            opponent.pendingGarbage += Math.abs(garbageToTake);
                            target.pendingGarbage = 0;
                        }
                    }

                    updateScoreAndLevel(target, clearedLineCount);
                    
                    if (!isOver) {
                        spawnPiece(target);
                        target.canHold = true;
                    }
                    updateUI();
                }
                
                function clearLines(target) {
                    return new Promise(resolve => {
                        let fullRows = [];
                        for (let y = 0; y < ROWS; y++) {
                            if (target.board[y].every(cell => cell)) fullRows.push(y);
                        }
                        if (fullRows.length === 0) return resolve(0);

                        if (!target.isCPU) playSound('delAudio');
                        const element = target.isCPU ? cpuBoardEl : boardEl;
                        if (!lowAnimationMode) {
                            element.classList.add('line-clearing-effect');
                            setTimeout(() => element.classList.remove('line-clearing-effect'), 400);
                            fullRows.forEach(y => {
                                for (let x = 0; x < COLS; x++) element.children[y * COLS + x].classList.add('line-clearing');
                            });
                        }
                        setTimeout(() => {
                            let newBoard = target.board.filter((_, y) => !fullRows.includes(y));
                            for (let i = 0; i < fullRows.length; i++) newBoard.unshift(Array(COLS).fill(null));
                            target.board = newBoard;
                            resolve(fullRows.length);
                        }, lowAnimationMode ? 20 : 350);
                    });
                }
                
                function addGarbageLines(target, lines) {
                    if (target.isOver) return;
                    const holeX = Math.floor(Math.random() * COLS);
                    for (let i = 0; i < lines; i++) {
                        target.board.shift();
                        const newRow = Array(COLS).fill('garbage');
                        newRow[holeX] = null;
                        target.board.push(newRow);
                    }
                    if (target.currentPiece && !isValidMove(target.currentPiece, target.board)) {
                        gameOver(target);
                    }
                }

                function updateScoreAndLevel(target, count) {
                    if (count === 0) return;
                    if (gameMode !== 'SPRINT') target.score += (POINTS[count] || 0) * target.level;
                    target.lines += count;
                    if (gameMode === 'SPRINT' && target.lines >= 40) { target.lines = 40; gameOver(target); }
                    if (count >= 4 && !target.isCPU) showFeedbackPopup(`PERFECT!`);
                    if (target.combo > 1 && !target.isCPU) {
                        showFeedbackPopup(`${target.combo} COMBO!`);
                        if (!lowAnimationMode) {
                            const boardWrap = target.isCPU ? cpuContainer.querySelector('.board') : boardEl;
                            const comboClass = `combo-${Math.min(4, Math.floor(target.combo / 2))}`;
                            boardWrap.classList.add(comboClass);
                            setTimeout(() => boardWrap.classList.remove(comboClass), 300);
                        }
                    }
                    if (gameMode === 'TRAINING' || gameMode === 'VS_CPU' || gameMode === 'ULTRA_VS_CPU') {
                        const newLevel = Math.floor(target.lines / 10) + 1;
                        if (newLevel > target.level) {
                            target.level = newLevel;
                            if (!target.isCPU) showFeedbackPopup(`Level ${target.level}`);
                            target.dropInterval = Math.max(100, 1000 - (target.level - 1) * 50);
                        }
                    }
                }

                function isValidMove(piece, board) {
                    for (let dy = 0; dy < piece.shape.length; dy++) {
                        for (let dx = 0; dx < piece.shape[dy].length; dx++) {
                            if (piece.shape[dy][dx]) {
                                const bX = piece.x + dx, bY = piece.y + dy;
                                if (bX < 0 || bX >= COLS || bY >= ROWS || (bY >= 0 && board[bY]?.[bX])) return false;
                            }
                        }
                    }
                    return true;
                }
                
                function createEmptyBoard(element) { element.innerHTML = Array.from({ length: ROWS * COLS }).map(() => `<div class="cell"></div>`).join(''); }

                function draw(target, element) {
                    if (!target || !element || (target.isOver && !isOver)) return;
                    const cells = Array.from(element.children);
                    cells.forEach(c => { c.innerHTML = ''; c.classList.remove('line-clearing'); });
                    
                    target.board.forEach((row, y) => row.forEach((color, x) => {
                        if (color) {
                            const tile = document.createElement('div');
                            tile.className = 'tile' + (color === 'garbage' ? ' garbage' : '');
                            if (color !== 'garbage') tile.style.color = color;
                            cells[y * COLS + x].appendChild(tile);
                        }
                    }));

                    if (target.currentPiece && !target.isOver) {
                        let ghostY = target.currentPiece.y;
                        while (isValidMove({ ...target.currentPiece, y: ghostY + 1 }, target.board)) ghostY++;
                        
                        target.currentPiece.shape.forEach((row, dy) => row.forEach((val, dx) => {
                            if (val) {
                                const x = target.currentPiece.x + dx, y = target.currentPiece.y + dy, gy = ghostY + dy;
                                if (gy >= 0 && cells[gy * COLS + x]) { const ghost = document.createElement('div'); ghost.className = 'ghost-tile'; cells[gy * COLS + x].appendChild(ghost); }
                                if (y >= 0 && cells[y * COLS + x]) { const tile = document.createElement('div'); tile.className = 'tile'; tile.style.color = target.currentPiece.color; cells[y * COLS + x].appendChild(tile); }
                            }
                        }));
                    }
                    if(devHUD.enabled) devHUD.perf.drawCalls++;
                }

                function drawPreview(container, piece) {
                    container.innerHTML = ''; if (!piece) return;
                    const grid = document.createElement('div'); grid.className = 'piece-grid';
                    const shape = TETROMINOS[piece.name].shape;
                    let minR = 4, maxR = -1, minC = 4, maxC = -1;
                    shape.forEach((r, y) => r.forEach((v, x) => { if (v) { minR = Math.min(minR, y); maxR = Math.max(maxR, y); minC = Math.min(minC, x); maxC = Math.max(maxC, x); } }));
                    const h = maxR - minR + 1, w = maxC - minC + 1;
                    grid.innerHTML = Array(16).fill('<div class="mini-cell"></div>').join('');
                    for (let r = 0; r < h; r++) for (let c = 0; c < w; c++) {
                        if (shape[minR + r][minC + c]) {
                            const sr = piece.name === 'I' ? 1 : Math.floor((4 - h) / 2);
                            const sc = Math.floor((4 - w) / 2);
                            const i = (sr + r) * 4 + (sc + c);
                            const t = document.createElement('div'); t.className = 'tile'; t.style.color = piece.color;
                            if (grid.children[i]) grid.children[i].appendChild(t);
                        }
                    }
                    container.appendChild(grid);
                }

                function setupUI() {
                    highScoreEl.textContent = bestScores.training || 0;
                    currentScoreEl.textContent = 0;
                    linesEl.textContent = 0;
                    levelEl.textContent = 1;
                    appContainer.classList.add('game-inactive-blur');
                }

                function updateUI() {
                    if (!player) return;
                    scoreBox.textContent = `Score: ${player.score}`;
                    currentScoreEl.textContent = player.score;
                    linesEl.textContent = player.lines;
                    levelEl.textContent = player.level;
                    let infoHtml = '';
                    switch (gameMode) {
                        case 'TRAINING': highScoreEl.textContent = bestScores.training || 0; modeInfoPanel.classList.add('hidden'); break;
                        case 'SPRINT': modeInfoTitle.textContent = "SPRINT"; infoHtml = `<div class="scorebox"><span>TIME</span><span>${formatTime(gameTimer)}</span></div><div class="scorebox"><span>BEST</span><span>${bestScores.sprint === Infinity ? 'N/A' : formatTime(bestScores.sprint)}</span></div><div class="scorebox"><span>LINES LEFT</span><span>${Math.max(0, 40 - player.lines)}</span></div>`; modeInfoPanel.classList.remove('hidden'); break;
                        case 'ULTRA': modeInfoTitle.textContent = "ULTRA"; infoHtml = `<div class="scorebox"><span>TIME LEFT</span><span>${formatTime(gameTimer)}</span></div><div class="scorebox"><span>HIGH</span><span>${bestScores.ultra || 0}</span></div><div class="scorebox"><span>SCORE</span><span>${player.score}</span></div>`; modeInfoPanel.classList.remove('hidden'); break;
                        case 'VS_CPU': modeInfoTitle.textContent = "VS CPU"; infoHtml = `<div class="scorebox"><span>CPU SCORE</span><span>${cpu?.score || 0}</span></div>`; modeInfoPanel.classList.remove('hidden'); break;
                        case 'ULTRA_VS_CPU': modeInfoTitle.textContent = "ULTRA VS CPU"; infoHtml = `<div class="scorebox"><span>TIME LEFT</span><span>${formatTime(gameTimer)}</span></div><div class="scorebox"><span>CPU SCORE</span><span>${cpu?.score || 0}</span></div>`; modeInfoPanel.classList.remove('hidden'); break;
                    }
                    modeInfoContent.innerHTML = infoHtml;
                    drawPreview(nextContainer, sharedNextPiece);
                    drawPreview(holdContainer, player.heldPiece);

                    if(devHUD.enabled) {
                      devHUD.progress.mode = gameMode; devHUD.progress.score = player.score; devHUD.progress.level = player.level; devHUD.progress.lines = player.lines; devHUD.progress.isOver = isOver;
                      devHUD.data.currentPiece = player.currentPiece?.name || 'None'; devHUD.data.nextPiece = sharedNextPiece?.name || 'None'; devHUD.data.heldPiece = player.heldPiece?.name || 'None';
                    }
                }

                function gameOver(loser) {
                    if (isOver) return;
                    isOver = true;
                    if (loser) loser.isOver = true;
                    
                    clearAllInputTimers();
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    if (gameInterval) clearInterval(gameInterval);
                    if (cpuActionInterval) clearInterval(cpuActionInterval);

                    const processResults = () => {
                        const titleEl = gameoverScreen.querySelector('h2');
                        if (gameMode === 'VS_CPU') {
                            titleEl.textContent = loser.isCPU ? "YOU WIN!" : "YOU LOSE...";
                            gameoverResult.textContent = `CPU LV.${cpuLevel} との対戦結果`;
                        } else if (gameMode === 'ULTRA_VS_CPU') {
                            titleEl.textContent = "TIME UP!";
                            gameoverResult.textContent = `You: ${player.score} vs CPU: ${cpu.score}`;
                             if (player.score > cpu.score) {
                                showFeedbackPopup("YOU WIN!");
                            } else if (player.score < cpu.score) {
                                showFeedbackPopup("YOU LOSE...");
                            } else {
                                showFeedbackPopup("DRAW!");
                            }
                        }
                        else {
                            switch (gameMode) {
                                case 'TRAINING': titleEl.textContent = "TRAINING COMPLETE"; gameoverResult.textContent = `Score: ${player.score}`; if (player.score > (bestScores.training || 0)) { bestScores.training = player.score; saveBestScores(); showFeedbackPopup("New High Score!"); } break;
                                case 'SPRINT': titleEl.textContent = "SPRINT COMPLETE"; gameoverResult.textContent = `Time: ${formatTime(gameTimer)}`; if (player.lines >= 40 && gameTimer < (bestScores.sprint || Infinity)) { bestScores.sprint = gameTimer; saveBestScores(); showFeedbackPopup("New Best Time!"); } break;
                                case 'ULTRA': titleEl.textContent = "TIME UP!"; gameoverResult.textContent = `Score: ${player.score}`; if (player.score > (bestScores.ultra || 0)) { bestScores.ultra = player.score; saveBestScores(); showFeedbackPopup("New High Score!"); } break;
                            }
                        }
                        showGameOverScreen();
                    };
                    playGameOverAnimation(loser).then(processResults);
                }

                function showStartScreen() {
                    if (countdownInterval) clearInterval(countdownInterval);
                    if (gameInterval) clearInterval(gameInterval);
                    if (cpuActionInterval) clearInterval(cpuActionInterval);
                    appContainer.classList.remove('vs-cpu-mode');
                    appContainer.classList.add('single-player-mode');
                    cpuContainer.classList.add('hidden');
                    countdownEl.classList.add('hidden');
                    gameOverlay.classList.remove('hidden');
                    startScreen.classList.remove('hidden');
                    gameoverScreen.classList.add('hidden');
                    pauseScreen.classList.add('hidden');
                    appContainer.classList.add('game-inactive-blur');
                    isOver = true; isPaused = true;
                    createEmptyBoard(boardEl); if(cpuBoardEl) createEmptyBoard(cpuBoardEl);
                    setupUI();
                    pauseButton.textContent = "停止";
                    vsCpuSelect.classList.remove('open');
                    ultraVsCpuSelect.classList.remove('open');
                }

                function showGameOverScreen() { gameOverlay.classList.remove('hidden'); startScreen.classList.add('hidden'); gameoverScreen.classList.remove('hidden'); pauseScreen.classList.add('hidden'); appContainer.classList.add('game-inactive-blur'); }
                function saveBestScores() { try { localStorage.setItem('blockfall_bests', JSON.stringify(bestScores)); } catch (e) { console.error("Failed to save scores:", e); } }
                function loadBestScores() {
                    try { const l = JSON.parse(localStorage.getItem('blockfall_bests')); return l ? { training: l.training || 0, sprint: l.sprint ?? Infinity, ultra: l.ultra || 0 } : { training: 0, sprint: Infinity, ultra: 0 };
                    } catch (e) { return { training: 0, sprint: Infinity, ultra: 0 }; }
                }
                function formatTime(s) { const m = Math.floor(s / 60); const sec = s % 60; return `${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`; }
                
                function clearAllInputTimers() { clearTimeout(dasTimer); clearInterval(arrTimer); clearInterval(softDropTimer); dasTimer = null; arrTimer = null; softDropTimer = null; }

                function setupKeyHandlers() {
                    document.addEventListener('keydown', e => {
                        if (actionToChange) return;
                        if (e.key === 'Enter' && !e.target.closest('.modal-overlay')) { document.getElementById('fake-translator').classList.toggle('hidden'); return; }
                        if (e.key === 'Escape' && !isOver && !document.querySelector('.modal-overlay:not(.hidden)')) { e.preventDefault(); togglePause(); return; }
                        if (isPaused || isOver || (player && player.isOver) || document.querySelector('.modal-overlay:not(.hidden)')) return;
                        if (!keys[e.key]) { const action = Object.keys(keyMap).find(act => keyMap[act].toLowerCase() === e.key.toLowerCase()); if (action) handleKeyPress(action); }
                        keys[e.key] = true;
                    });
                    document.addEventListener('keyup', e => {
                        const action = Object.keys(keyMap).find(act => keyMap[act].toLowerCase() === e.key.toLowerCase());
                        if (keys[e.key] && (action === 'moveLeft' || action === 'moveRight')) { clearTimeout(dasTimer); clearInterval(arrTimer); dasTimer = null; arrTimer = null; }
                        if (keys[e.key] && action === 'softDrop') { clearInterval(softDropTimer); softDropTimer = null; }
                        keys[e.key] = false;
                    });
                    window.addEventListener('blur', () => { keys = {}; clearAllInputTimers(); });
                }

                function handleKeyPress(action) {
                    if (isOver || isPaused || player.isOver) return;
                    switch (action) {
                        case 'moveLeft': clearAllInputTimers(); move(player, -1); dasTimer = setTimeout(() => { arrTimer = setInterval(() => move(player, -1), ARR_DELAY); }, DAS_DELAY); break;
                        case 'moveRight': clearAllInputTimers(); move(player, 1); dasTimer = setTimeout(() => { arrTimer = setInterval(() => move(player, 1), ARR_DELAY); }, DAS_DELAY); break;
                        case 'softDrop': drop(player); softDropTimer = setInterval(() => drop(player), SOFT_DROP_DELAY); break;
                        case 'hardDrop': hardDrop(player); break;
                        case 'rotateLeft': rotate(player, -1); break;
                        case 'rotateRight': rotate(player, 1); break;
                        case 'hold': hold(player); break;
                    }
                }

                function playHardDropAnimation(target) { if (lowAnimationMode) return; playerGameContainer.classList.add('shake-hard-drop'); setTimeout(()=> playerGameContainer.classList.remove('shake-hard-drop'), 150); for (let i = 0; i < 15; i++) { const p = document.createElement('div'); p.className = 'particle'; document.body.appendChild(p); const rect = boardEl.getBoundingClientRect(), cw = rect.width / COLS, ch = rect.height / ROWS, sx = rect.left + (Math.random() * COLS) * cw, sy = rect.top + (target.currentPiece.y + 0.5) * ch; p.style.left = `${sx}px`; p.style.top = `${sy}px`; const ang = Math.random() * Math.PI - Math.PI, vel = Math.random() * 80 + 40, ex = Math.cos(ang) * vel, ey = Math.sin(ang) * vel - 30; p.style.setProperty('--x', `${ex}px`); p.style.setProperty('--y', `${ey}px`); setTimeout(() => p.remove(), 600); } }
                function playGameOverAnimation(target) {
                    return new Promise(resolve => {
                        if (!target || target.isOver === false) return resolve();
                        let row = ROWS - 1;
                        const el = target.isCPU ? cpuBoardEl : boardEl;
                        const i = setInterval(() => {
                            if (row < 0) { clearInterval(i); setTimeout(resolve, 300); return; }
                            for (let c = 0; c < COLS; c++) el.children[row * COLS + c].classList.add('dead');
                            row--;
                        }, 30);
                    });
                }
                function playSound(id) { if (!soundToggle.checked) return; const a = document.getElementById(id); if (a) { a.currentTime = 0; a.play().catch(() => {}); } }
                function showFeedbackPopup(text) { const p = document.createElement('div'); p.textContent = text; p.className = 'feedback-popup'; document.body.appendChild(p); p.addEventListener('animationend', () => p.remove()); }
                function loadKeyMap() { try { const s = JSON.parse(localStorage.getItem('blockfall_keymap')); keyMap = s ? { ...defaultKeyMap, ...s } : { ...defaultKeyMap }; } catch (e) { keyMap = { ...defaultKeyMap }; } }
                function saveKeyMap() { try { localStorage.setItem('blockfall_keymap', JSON.stringify(keyMap)); } catch (e) { alert('設定の保存に失敗しました。'); } }
                function setupKeyConfigModal() {
                    const modal = document.getElementById('keyConfigModal'), keyConfigList = document.getElementById('key-config-list'), saveBtn = document.getElementById('saveKeysBtn'), resetBtn = document.getElementById('resetKeysBtn');
                    document.getElementById('menu-key-config-btn').addEventListener('click', () => { populateKeyConfigList(); modal.classList.remove('hidden'); });
                    saveBtn.addEventListener('click', () => { saveKeyMap(); modal.classList.add('hidden'); showFeedbackPopup('キー設定を保存しました'); });
                    resetBtn.addEventListener('click', () => { if (confirm('キー設定を初期状態に戻しますか？')) { keyMap = { ...defaultKeyMap }; populateKeyConfigList(); } });
                    modal.addEventListener('click', (e) => { if (e.target === modal) { modal.classList.add('hidden'); } });
                    function populateKeyConfigList() {
                        keyConfigList.innerHTML = '';
                        for (const action in actionLabels) { const item = document.createElement('div'); item.className = 'key-config-item'; item.innerHTML = `<span class="action-label">${actionLabels[action]}</span><span class="key-display" data-action="${action}">${keyMap[action]}</span>`; keyConfigList.appendChild(item); }
                        document.querySelectorAll('.key-display').forEach(el => { el.addEventListener('click', startKeyChange); });
                    }
                    function startKeyChange(e) { if (actionToChange) return; const targetEl = e.target; actionToChange = targetEl.dataset.action; targetEl.textContent = 'キーを押して下さい'; targetEl.classList.add('listening'); document.addEventListener('keydown', captureKey, { capture: true, once: true }); document.addEventListener('click', cancelKeyChange, { once: true }); }
                    function captureKey(e) {
                        e.preventDefault(); e.stopPropagation();
                        const newKey = e.key; const currentEl = document.querySelector(`.key-display[data-action="${actionToChange}"]`);
                        if (newKey === 'Escape') { if (currentEl) currentEl.textContent = keyMap[actionToChange]; }
                        else {
                            const isUsed = Object.values(keyMap).some(k => k.toLowerCase() === newKey.toLowerCase());
                            if (isUsed && keyMap[actionToChange].toLowerCase() !== newKey.toLowerCase()) { alert(`キー「${newKey}」は既に使用されています。`); if (currentEl) currentEl.textContent = keyMap[actionToChange]; }
                            else { keyMap[actionToChange] = newKey; if (currentEl) currentEl.textContent = newKey; }
                        }
                        if (currentEl) currentEl.classList.remove('listening');
                        document.removeEventListener('click', cancelKeyChange);
                        actionToChange = null;
                    }
                    function cancelKeyChange(e) { if (e.target.dataset.action !== actionToChange) { const currentEl = document.querySelector(`.key-display[data-action="${actionToChange}"]`); if (currentEl) { currentEl.textContent = keyMap[actionToChange]; currentEl.classList.remove('listening'); } document.removeEventListener('keydown', captureKey, { capture: true }); actionToChange = null; } }
                }

                function setupExtraFeatures() {
                    const cheatCodeModal = document.getElementById('cheatCodeModal'), cheatInput = document.getElementById('cheatInput'), submitCheatBtn = document.getElementById('submitCheatBtn'), closeCheatBtn = document.getElementById('closeCheatBtn');
                    menuCheatBtn.addEventListener('click', () => { cheatCodeModal?.classList.remove('hidden'); menuPanel.classList.remove('open'); });
                    if (closeCheatBtn) closeCheatBtn.addEventListener('click', () => cheatCodeModal.classList.add('hidden'));
                    if (submitCheatBtn) submitCheatBtn.addEventListener('click', handleCheatCode);
                    if (cheatInput) cheatInput.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') handleCheatCode(); });
                    
                    const menuShareBtn = document.getElementById('menu-share-btn'), shareModal = document.getElementById('shareModal'), qrcodeContainer = document.getElementById('qrcode'), urlInput = document.getElementById('urlInput'), copyUrlBtn = document.getElementById('copyUrlBtn'), closeShareBtn = document.getElementById('closeShareBtn'), bgmAudio = document.getElementById('bgmAudio'), translatorInput = document.getElementById('translator-input'), translatorOutput = document.getElementById('translator-output');
                    hamburgerIcon.addEventListener('click', () => menuPanel.classList.toggle('open'));
                    const savedSoundSetting = localStorage.getItem('blockfall_sound');
                    if (savedSoundSetting !== null) soundToggle.checked = savedSoundSetting === 'true';
                    const playBGM = () => { if (soundToggle.checked && bgmAudio) bgmAudio.play().catch(() => {}); };
                    document.body.addEventListener('click', playBGM, { once: true });
                    soundToggle.addEventListener('change', (e) => { try { localStorage.setItem('blockfall_sound', e.target.checked); } catch (err) {} if (e.target.checked && bgmAudio) bgmAudio.play().catch(() => {}); else if (bgmAudio) bgmAudio.pause(); });
                    if (menuShareBtn) menuShareBtn.addEventListener('click', () => { if (!shareModal) return; const url = window.location.href; if (urlInput) urlInput.value = url; if (qrcodeContainer) qrcodeContainer.innerHTML = ''; if (typeof QRCode !== 'undefined') { QRCode.toCanvas(url, { width: 200, errorCorrectionLevel: 'H' }, (err, canvas) => { if (err) { console.error(err); return; } if (qrcodeContainer) qrcodeContainer.appendChild(canvas); }); } shareModal.classList.remove('hidden'); menuPanel.classList.remove('open'); });
                    if (closeShareBtn) closeShareBtn.addEventListener('click', () => shareModal.classList.add('hidden'));
                    if (copyUrlBtn) copyUrlBtn.addEventListener('click', () => { if (urlInput) { urlInput.select(); navigator.clipboard.writeText(urlInput.value).then(() => { copyUrlBtn.textContent = 'コピー完了!'; setTimeout(() => { copyUrlBtn.textContent = 'コピー'; }, 2000); }); } });
                    const originalTitle = document.title, favicon = document.getElementById('favicon'), originalFavicon = favicon ? favicon.href : '', fakeTitle = '翻訳', fakeFavicon = 'data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🌐</text></svg>';
                    window.addEventListener('blur', () => { document.title = fakeTitle; if (favicon) favicon.href = fakeFavicon; });
                    window.addEventListener('focus', () => { document.title = originalTitle; if (favicon) favicon.href = originalFavicon; });
                    if (translatorInput) { translatorInput.addEventListener('keyup', () => { if (translatorOutput) translatorOutput.value = translatorInput.value.toLowerCase().split('').map(char => ({ 'a': 'b', 'あ': 'い', 'i': 'j' })[char] || char).join(''); }); }
                }

                function handleCheatCode() {
                    const cheatInput = document.getElementById('cheatInput'), cheatCodeModal = document.getElementById('cheatCodeModal');
                    const code = cheatInput.value.trim().toLowerCase();
                    if (code === 'towa.soko0406') {
                        const newScoreStr = prompt('新しいスコアを入力:', player.score);
                        const newScore = parseInt(newScoreStr, 10);
                        if (!isNaN(newScore)) { player.score = newScore; updateUI(); } else { alert('無効な数値'); }
                    } else if (code === 'deletadata' || code === 'reset') {
                        try { localStorage.removeItem('blockfall_bests'); localStorage.removeItem('blockfall_keymap'); localStorage.removeItem('blockfall_sound'); alert('全モードのハイスコアとキー設定を削除しました'); location.reload(); } catch (e) { alert('削除失敗'); }
                    } else { alert('コードが違います'); }
                    if (cheatInput) cheatInput.value = '';
                    if (cheatCodeModal) cheatCodeModal.classList.add('hidden');
                }

                function setupDevMode() {
                    const devPasswordModal = document.getElementById('devPasswordModal'), devPasswordInput = document.getElementById('devPasswordInput'), submitDevPasswordBtn = document.getElementById('submitDevPasswordBtn'), closeDevPasswordBtn = document.getElementById('closeDevPasswordBtn');
                    document.getElementById('menu-dev-mode-btn').addEventListener('click', () => { devPasswordModal.classList.remove('hidden'); devPasswordInput.focus(); menuPanel.classList.remove('open'); });
                    closeDevPasswordBtn.addEventListener('click', () => devPasswordModal.classList.add('hidden'));
                    submitDevPasswordBtn.addEventListener('click', handleDevPassword);
                    devPasswordInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleDevPassword(); });
                    devHUD.elements.hud.addEventListener('click', (e) => {
                        if (!devHUD.enabled || e.target.dataset.action !== 'set-score') return;
                        const newScoreStr = prompt('新しいスコアを入力してください:', player.score);
                        const newScore = parseInt(newScoreStr, 10);
                        if (!isNaN(newScore) && newScore >= 0) { player.score = newScore; logToDevConsole(`Score changed to ${player.score}`); updateUI(); }
                        else { alert('無効な数値です。'); }
                    });
                }
                function handleDevPassword() {
                    const devPasswordInput = document.getElementById('devPasswordInput'), devPasswordModal = document.getElementById('devPasswordModal');
                    const password = devPasswordInput.value.trim();
                    if (password === 'towa.soko0406') {
                        devHUD.enabled = !devHUD.enabled;
                        devHUD.debug.flags.devMode = devHUD.enabled;
                        devHUD.debug.flags.lowAnim = lowAnimationMode;
                        if (devHUD.enabled) { devHUD.elements.hud.classList.remove('hidden'); devHUD.elements.console.classList.remove('hidden'); alert('開発者モードが有効になりました。'); } 
                        else { devHUD.elements.hud.classList.add('hidden'); devHUD.elements.console.classList.add('hidden'); alert('開発者モードが無効になりました。'); }
                    } else if (password === 'reset') {
                        if (confirm('本当に保存されているデータを全てリセットしますか？')) {
                            try { localStorage.clear(); alert('データをリセットしました。ページをリロードします。'); location.reload(); } 
                            catch (e) { alert('データのリセットに失敗しました。'); }
                        }
                    } else { alert('パスワードが違います。'); }
                    devPasswordModal.classList.add('hidden');
                    devPasswordInput.value = '';
                }

                function runCpuTurn(cpu) {
                    if (isOver || cpu.isOver || !cpu.currentPiece || cpu.ai.isThinking) return;
                    cpu.ai.isThinking = true;
                    setTimeout(() => {
                        const bestMoves = findBestMoves(cpu);
                        if (!bestMoves || bestMoves.length === 0) { cpu.ai.isThinking = false; return; }
                        let bestMove;
                        
                        if (cpuLevel <= 6 && Math.random() < 0.04) {
                            bestMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];
                        } else {
                            bestMove = bestMoves[0];
                            if (Math.random() < CPU_LEVELS[cpuLevel].mistakeChance && bestMoves.length > 1) {
                                bestMove = bestMoves[1 + Math.floor(Math.random() * Math.min(2, bestMoves.length - 1))];
                            }
                        }

                        cpu.ai.actionQueue = planCpuMoves(cpu, bestMove.move);
                        cpu.ai.isThinking = false;
                    }, CPU_LEVELS[cpuLevel].thinkTime + Math.random() * 50);
                }
                function planCpuMoves(cpu, bestMove) {
                    if (!bestMove || !cpu.currentPiece) return [];
                    const queue = [];
                    if (bestMove.isHold) { queue.push('hold'); return queue; }
                    const p = { ...cpu.currentPiece, shape: JSON.parse(JSON.stringify(cpu.currentPiece.shape))};
                    for(let i = 0; i < bestMove.rotation; i++) { queue.push('rotate'); }
                    const finalX = bestMove.x;
                    let startX = p.x;
                    const moveDiff = finalX - startX;
                    const moveDir = moveDiff > 0 ? 'moveRight' : 'moveLeft';
                    for (let i = 0; i < Math.abs(moveDiff); i++) queue.push(moveDir);
                    queue.push('hardDrop');
                    return queue;
                }
                function executeCpuAction() {
                    const action = cpu.ai.actionQueue.shift();
                    if (!action) return;
                    switch (action) {
                        case 'rotate': rotate(cpu, 1); break;
                        case 'moveLeft': move(cpu, -1); break;
                        case 'moveRight': move(cpu, 1); break;
                        case 'hardDrop': hardDrop(cpu); break;
                        case 'hold': hold(cpu); break;
                    }
                }
                function findBestMoves(target) {
                    let moves = [];
                    const checkPiece = (piece, isHold) => {
                        if (!piece) return;
                        for (let r = 0; r < 4; r++) {
                            let tempPiece = { ...piece, rotation: 0, shape: JSON.parse(JSON.stringify(TETROMINOS[piece.name].shape)) };
                            for(let i = 0; i < r; i++) {
                                tempPiece.shape = tempPiece.shape[0].map((_, c) => tempPiece.shape.map(row => row[c]).reverse());
                                tempPiece.rotation = (tempPiece.rotation + 1) % 4;
                            }
                            
                            for (let x = -2; x < COLS; x++) {
                                tempPiece.x = x;
                                tempPiece.y = 0;
                                let y = 0;
                                while (isValidMove({ ...tempPiece, y: y + 1 }, target.board)) y++;
                                tempPiece.y = y;
                                if (!isValidMove(tempPiece, target.board)) continue;

                                let tempBoard = target.board.map(row => [...row]);
                                tempPiece.shape.forEach((row, dy) => row.forEach((v, dx) => { if (v && tempPiece.y + dy >= 0) tempBoard[tempPiece.y + dy][tempPiece.x + dx] = '1'; }));
                                moves.push({ move: { rotation: r, x: tempPiece.x, isHold }, score: evaluateBoard(tempBoard, CPU_LEVELS[cpuLevel].weights) });
                            }
                        }
                    };
                    checkPiece(target.currentPiece, false);
                    if (target.canHold) {
                        const pieceToConsider = target.heldPiece || sharedNextPiece;
                        checkPiece(pieceToConsider, true);
                    }
                    return moves.sort((a, b) => b.score - a.score);
                }
                function evaluateBoard(board, weights) {
                    const {AGG_H, COMP_L, HOLES, BUMP, WELLS} = weights;
                    const heights = Array(COLS).fill(0);
                    let aggHeight = 0, holes = 0;
                    for (let c = 0; c < COLS; c++) {
                        let blockFound = false;
                        for (let r = 0; r < ROWS; r++) {
                            if (board[r][c]) {
                                if (!blockFound) { heights[c] = ROWS - r; blockFound = true; }
                            } else if (blockFound) holes++;
                        }
                        aggHeight += heights[c];
                    }
                    let completedLines = 0;
                    for (let r = 0; r < ROWS; r++) if (board[r].every(cell => cell)) completedLines++;
                    let bumpiness = 0, wells = 0;
                    for (let c = 0; c < COLS; c++) {
                        if (c > 0) bumpiness += Math.abs(heights[c] - heights[c - 1]);
                        const left = heights[c - 1] || ROWS, right = heights[c + 1] || ROWS;
                        if (left > heights[c] && right > heights[c]) wells += Math.min(left - heights[c], right - heights[c]);
                    }
                    return AGG_H * aggHeight + COMP_L * (completedLines ** 2) + HOLES * holes + BUMP * bumpiness + WELLS * wells;
                }
                
                init();
            }
        </script>
    </body>
</html>
