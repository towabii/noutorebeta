<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音響信号変換アプリ v13.1 (高信頼性受信版)</title>
    <style>
        /* CSSは変更なしのため省略 */
        :root {
            --bg-color: #f0f2f5; --fg-color: #ffffff; --text-color: #1c1c1e;
            --primary-color: #007aff; --primary-hover: #0056b3; --border-color: #e0e0e0;
            --shadow-color: rgba(0, 0, 0, 0.1); --success-color: #34c759; --error-color: #ff3b30;
        }
        html.dark-mode {
            --bg-color: #1c1c1e; --fg-color: #2c2c2e; --text-color: #f2f2f7;
            --primary-color: #0a84ff; --primary-hover: #0060df; --border-color: #444446;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }
        @keyframes pulse-border {
            0% { border-color: var(--primary-color); }
            50% { border-color: var(--success-color); }
            100% { border-color: var(--primary-color); }
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color); color: var(--text-color);
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; margin: 0; padding: 1rem; box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s;
        }
        .container {
            background-color: var(--fg-color); padding: 2.5rem; border-radius: 1.5rem;
            box-shadow: 0 8px 32px var(--shadow-color); width: 100%; max-width: 700px;
            text-align: center; transition: background-color 0.3s;
        }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; }
        h1 { color: var(--primary-color); margin: 0; font-size: 2rem; }
        .theme-switch { display: flex; align-items: center; cursor: pointer; }
        .theme-switch input { display: none; }
        .slider { width: 40px; height: 20px; background: #ccc; border-radius: 20px; position: relative; transition: background 0.3s; }
        .slider:before { content: ''; position: absolute; width: 16px; height: 16px; background: white; border-radius: 50%; top: 2px; left: 2px; transition: transform 0.3s; }
        .theme-switch input:checked + .slider { background-color: var(--primary-color); }
        .theme-switch input:checked + .slider:before { transform: translateX(20px); }
        .section { margin-bottom: 2rem; }
        #playback-display {
            font-size: 1.2rem; margin-bottom: 0.5rem; color: var(--text-color); min-height: 1.5em;
            letter-spacing: 2px;
        }
        #playback-display .highlight {
            background-color: var(--primary-color); color: white; border-radius: 3px;
        }
        textarea { width: 100%; height: 120px; padding: 1rem; border: 1px solid var(--border-color); border-radius: 0.75rem; font-size: 1rem; resize: vertical; box-sizing: border-box; background-color: var(--bg-color); color: var(--text-color); }
        button { background-color: var(--primary-color); color: #fff; border: none; padding: 1rem 2rem; border-radius: 0.75rem; cursor: pointer; font-size: 1rem; font-weight: 600; transition: background-color 0.3s, transform 0.1s; margin-top: 1rem; }
        button:hover:not(:disabled) { background-color: var(--primary-hover); }
        button:active:not(:disabled) { transform: scale(0.98); }
        button:disabled { background-color: #8e8e93; opacity: 0.7; cursor: not-allowed; }
        .receiver-area { position: relative; }
        #kanji-convert-button { position: absolute; bottom: 5px; right: 5px; padding: 0.3rem 0.8rem; font-size: 0.8rem; margin-top: 0; background-color: var(--success-color); display: none; }
        #result-display { margin-top: 1rem; padding: 1rem; border: 2px dashed var(--border-color); border-radius: 0.75rem; min-height: 50px; background-color: var(--bg-color); font-size: 1.2rem; font-weight: bold; color: var(--error-color); text-align: left; word-wrap: break-word; }
        #result-display.receiving { animation: pulse-border 1.5s infinite; }
        .status { margin-top: 1rem; color: #8e8e93; font-style: italic; min-height: 1.2em; }
        @media (max-width: 600px) { body { padding: 0.5rem; } .container { padding: 1.5rem; } h1 { font-size: 1.5rem; } }
    </style>
</head>
<body>
<div class="container">
    <div class="header"><h1>音響信号 v13.1</h1> <label class="theme-switch"><input type="checkbox" id="theme-toggle"><span class="slider"></span></label></div>
    <div class="section">
        <div id="playback-display"></div>
        <textarea id="text-input" placeholder="ひらがな・カタカナでメッセージを入力"></textarea>
        <button id="play-button">音に変換して再生</button>
    </div>
    <div class="section"><button id="listen-button">マイクで読み取り開始</button><div class="receiver-area"><div id="result-display"></div><button id="kanji-convert-button">漢字に変換</button></div><p class="status" id="status-text">待機中</p></div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
    // グローバル変数 & DOM要素 (変更なし)
    let audioContext; let audioStream; let analyser; let animationFrameId;
    let isListening = false; let isTransmitting = false;
    let listeningState = 'IDLE'; let lastDetectionTime = 0;
    const textInput = document.getElementById('text-input'), playButton = document.getElementById('play-button');
    const listenButton = document.getElementById('listen-button'), resultDisplay = document.getElementById('result-display');
    const statusText = document.getElementById('status-text'), themeToggle = document.getElementById('theme-toggle');
    const kanjiConvertButton = document.getElementById('kanji-convert-button'), playbackDisplay = document.getElementById('playback-display');

    // 信号定義 (変更なし)
    const NOTE_DURATION = 0.13, PAUSE_DURATION = 0.09;
    const START_SIGNAL_FREQ = 300, END_SIGNAL_FREQ = 4000;
    const charToFreqPair = {};
    let LOW_FREQUENCIES, HIGH_FREQUENCIES;

    function assignFrequencies() {
        LOW_FREQUENCIES = [697, 770, 852, 941, 1046, 1150];
        HIGH_FREQUENCIES = [1336, 1477, 1633, 1800, 1980, 2150, 2350, 2550, 2780, 3000, 3250, 3500, 3750];
        const allChars = `あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをんがぎぐげござじずぜぞだぢづでどばびぶべぼぱぴぷぺぽぁぃぅぇぉゃゅょっアイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲンガギグゲゴザジズゼゾダヂヅデドバビブベボパピプペポァィゥェォャュョッー、。？！「」`;
        const chars = [...new Set(allChars.split(''))].sort();
        if (chars.length > LOW_FREQUENCIES.length * HIGH_FREQUENCIES.length) { console.error("エラー: 対応文字数が周波数の組み合わせ上限を超えています。"); return; }
        chars.forEach((char, i) => { const lowIndex = Math.floor(i / HIGH_FREQUENCIES.length) % LOW_FREQUENCIES.length; const highIndex = i % HIGH_FREQUENCIES.length; charToFreqPair[char] = { f1: LOW_FREQUENCIES[lowIndex], f2: HIGH_FREQUENCIES[highIndex] }; });
    }

    // 初期化処理 (変更なし)
    assignFrequencies();
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches, savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark' || (!savedTheme && prefersDark)) { document.documentElement.classList.add('dark-mode'); themeToggle.checked = true; }
    
    // AudioContext管理 (変更なし)
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    async function initializeAudioContext() {
        if (!audioContext) { try { audioContext = new AudioContext(); } catch (e) { statusText.textContent = "このブラウザはWeb Audio APIをサポートしていません。"; return false; } }
        if (audioContext.state === 'suspended') { try { await audioContext.resume(); } catch (e) { statusText.textContent = "音声の再生を開始できませんでした。"; return false; } }
        return true;
    }

    // テキストを音に変換 (変更なし)
    async function playSequence(sequence, textSpans) { /* ...前回のコードと同じ... */ 
        let cumulativeTime = 0;
        const baseTime = audioContext.currentTime;
        for (let i = 0; i < sequence.length; i++) {
            const {f1, f2} = sequence[i];
            const isCharSignal = i > 0 && i < sequence.length - 1;
            const playTime = baseTime + cumulativeTime;
            if (isCharSignal && textSpans[i-1]) {
                setTimeout(() => textSpans[i-1].classList.add('highlight'), cumulativeTime * 1000);
                setTimeout(() => textSpans[i-1].classList.remove('highlight'), (cumulativeTime + NOTE_DURATION) * 1000);
            }
            [f1, f2].forEach(freq => {
                if (!freq) return;
                const oscillator = audioContext.createOscillator(), gainNode = audioContext.createGain();
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(freq, playTime);
                gainNode.gain.setValueAtTime(0, playTime);
                gainNode.gain.linearRampToValueAtTime(0.5, playTime + 0.01);
                gainNode.gain.linearRampToValueAtTime(0, playTime + NOTE_DURATION);
                oscillator.connect(gainNode).connect(audioContext.destination);
                oscillator.start(playTime);
                oscillator.stop(playTime + NOTE_DURATION);
            });
            cumulativeTime += NOTE_DURATION + PAUSE_DURATION;
        }
        return new Promise(resolve => setTimeout(resolve, cumulativeTime * 1000));
    }
    
    // ==========================================================
    // ★ 修正点: 音をテキストに変換 (高信頼性受信ロジック)
    // ==========================================================
    function analyzeSound() {
        if (!isListening) return;
        const dataArray = new Float32Array(analyser.frequencyBinCount);
        analyser.getFloatFrequencyData(dataArray);

        // ★ 修正点: 信号検出ロジックを刷新
        const signal = findClosestSignalFromData(dataArray);
        const now = Date.now();

        // 検出後の処理は同じだが、検出精度が向上している
        if (signal && now - lastDetectionTime > (NOTE_DURATION + PAUSE_DURATION) * 1000 * 0.9) {
            if (listeningState === 'IDLE' && signal.type === 'START') {
                listeningState = 'RECEIVING';
                statusText.textContent = '信号受信中...';
                resultDisplay.classList.add('receiving');
            } else if (listeningState === 'RECEIVING') {
                if (signal.type === 'END') {
                    listeningState = 'IDLE';
                    statusText.textContent = '受信完了。「開始信号」待機中...';
                    if (resultDisplay.textContent) kanjiConvertButton.style.display = 'inline-block';
                    resultDisplay.classList.remove('receiving');
                } else if (signal.type === 'CHAR') {
                    resultDisplay.textContent += signal.char;
                }
            }
            lastDetectionTime = now;
        }
        animationFrameId = requestAnimationFrame(analyzeSound);
    }
    
    // ★ 修正点: 特定周波数帯域で最も強い信号を探すヘルパー関数
    function findPeakFrequencyInRange(data, startFreq, endFreq) {
        const freqToIndex = freq => Math.round(freq * analyser.fftSize / audioContext.sampleRate);
        const startIndex = freqToIndex(startFreq);
        const endIndex = freqToIndex(endFreq);
        
        let maxMagnitude = -Infinity;
        let maxIndex = -1;

        for (let i = startIndex; i <= endIndex; i++) {
            if (data[i] > maxMagnitude) {
                maxMagnitude = data[i];
                maxIndex = i;
            }
        }
        
        const peakFreq = maxIndex * audioContext.sampleRate / analyser.fftSize;
        return { freq: peakFreq, magnitude: maxMagnitude };
    }

    // ★ 修正点: 新しいロジックに基づいた信号判定関数
    function findClosestSignalFromData(data) {
        const THRESHOLD = -50; // 環境に応じて調整可能な閾値
        const TOLERANCE = 40;  // 検出された周波数と定義周波数の許容誤差(Hz)

        // 単一周波数のSTART/END信号をチェック
        const freqToIndex = freq => Math.round(freq * analyser.fftSize / audioContext.sampleRate);
        if (data[freqToIndex(START_SIGNAL_FREQ)] > THRESHOLD) return { type: 'START' };
        if (data[freqToIndex(END_SIGNAL_FREQ)] > THRESHOLD) return { type: 'END' };

        // 低周波数帯と高周波数帯でそれぞれピークを探す
        const lowPeak = findPeakFrequencyInRange(data, LOW_FREQUENCIES[0] - 50, LOW_FREQUENCIES[LOW_FREQUENCIES.length - 1] + 50);
        const highPeak = findPeakFrequencyInRange(data, HIGH_FREQUENCIES[0] - 50, HIGH_FREQUENCIES[HIGH_FREQUENCIES.length - 1] + 50);

        // 両方のピークが閾値を超えているか確認
        if (lowPeak.magnitude < THRESHOLD || highPeak.magnitude < THRESHOLD) {
            return null;
        }

        let bestMatchChar = null;
        let minDistance = Infinity;

        // 最も近い周波数の組み合わせを持つ文字を探す
        for (const char in charToFreqPair) {
            const { f1, f2 } = charToFreqPair[char];
            const distance = Math.abs(f1 - lowPeak.freq) + Math.abs(f2 - highPeak.freq);
            
            if (distance < minDistance) {
                minDistance = distance;
                bestMatchChar = char;
            }
        }

        // 最も近い組み合わせが許容誤差内であれば、その文字を返す
        if (minDistance < TOLERANCE) {
            return { type: 'CHAR', char: bestMatchChar };
        }

        return null;
    }

    // マイク起動/停止 (変更なし)
    async function startListening() {
        if (!(await initializeAudioContext())) return;
        try {
            audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const source = audioContext.createMediaStreamSource(audioStream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 8192;
            analyser.smoothingTimeConstant = 0.5;
            source.connect(analyser);
            isListening = true;
            listeningState = 'IDLE';
            listenButton.textContent = '停止';
            playButton.disabled = true;
            statusText.textContent = '「開始信号」待機中...';
            resultDisplay.textContent = '';
            kanjiConvertButton.style.display = 'none';
            analyzeSound();
        } catch (err) {
            statusText.textContent = 'マイクの起動に失敗。アクセスを許可してください。';
            console.error("マイク起動エラー:", err);
            isListening = false;
        }
    }

    function stopListening() { /* ...前回のコードと同じ... */ 
        if (audioStream) audioStream.getTracks().forEach(track => track.stop());
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        isListening = false;
        listenButton.textContent = 'マイクで読み取り開始';
        playButton.disabled = false;
        statusText.textContent = '待機中';
        resultDisplay.classList.remove('receiving');
    }

    // かな漢字変換 (変更なし, 動作しない可能性あり)
    async function convertToKanji() { /* ...前回のコードと同じ... */ 
        const text = resultDisplay.textContent; if (!text) return; kanjiConvertButton.textContent = '変換中...'; kanjiConvertButton.disabled = true; try { const url = `https://www.google.com/transliterate?langpair=ja-Hira|ja&text=${encodeURIComponent(text)}`; const res = await fetch(url); if (!res.ok) throw new Error(`API Error: ${res.statusText}`); const data = await res.json(); if (data && data.length > 0) { resultDisplay.textContent = data.map(seg => seg[1][0]).join(''); } else { throw new Error('変換データが空'); } } catch (e) { statusText.textContent = '漢字変換に失敗しました。'; console.error(e); } finally { kanjiConvertButton.textContent = '漢字に変換'; kanjiConvertButton.disabled = false; kanjiConvertButton.style.display = 'none'; }
    }

    // イベントリスナー (変更なし)
    themeToggle.addEventListener('change', () => { document.documentElement.classList.toggle('dark-mode'); localStorage.setItem('theme', themeToggle.checked ? 'dark' : 'light'); });
    playButton.addEventListener('click', async () => { if (isTransmitting || isListening) return; if (!(await initializeAudioContext())) return; const text = textInput.value; if (!text) return; isTransmitting = true; playButton.disabled = true; listenButton.disabled = true; statusText.textContent = "信号を送信中..."; playbackDisplay.innerHTML = [...text].map(c => `<span>${c}</span>`).join(''); const textSpans = playbackDisplay.querySelectorAll('span'); const sequence = [{f1: START_SIGNAL_FREQ}]; for (const char of text) { if (charToFreqPair[char]) sequence.push(charToFreqPair[char]); } sequence.push({f1: END_SIGNAL_FREQ}); await playSequence(sequence, textSpans); isTransmitting = false; playButton.disabled = false; listenButton.disabled = false; statusText.textContent = "送信完了"; });
    listenButton.addEventListener('click', () => { if (isTransmitting) return; isListening ? stopListening() : startListening(); });
    kanjiConvertButton.addEventListener('click', convertToKanji);
});
</script>
</body>
</html>
